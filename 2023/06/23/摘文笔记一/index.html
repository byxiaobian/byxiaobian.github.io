<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>摘文笔记_常用技术一 | By_Xb</title><meta name="keywords" content="Spring-Boot,Docker,springmvc,Java"><meta name="author" content="By_Xb"><meta name="copyright" content="By_Xb"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Log4j2使用以及异步性能  ,  Springboot全局异常处理   ,  Springboot自定义注解+拦截器实现敏感数据加解密  ,  Docker图形化工具    , SpringMVC:注解@ControllerAdvice的工作原理   ,  出路重复请求并转发   , SpringAOP详解   , java8 Stream流失编程.      Log4j2使用以及异步性能L"><meta property="og:type" content="article"><meta property="og:title" content="摘文笔记_常用技术一"><meta property="og:url" content="https://wtnl.xyz/2023/06/23/%E6%91%98%E6%96%87%E7%AC%94%E8%AE%B0%E4%B8%80/index.html"><meta property="og:site_name" content="By_Xb"><meta property="og:description" content="Log4j2使用以及异步性能  ,  Springboot全局异常处理   ,  Springboot自定义注解+拦截器实现敏感数据加解密  ,  Docker图形化工具    , SpringMVC:注解@ControllerAdvice的工作原理   ,  出路重复请求并转发   , SpringAOP详解   , java8 Stream流失编程.      Log4j2使用以及异步性能L"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/320"><meta property="article:published_time" content="2023-06-23T06:47:58.937Z"><meta property="article:modified_time" content="2021-06-06T02:05:40.000Z"><meta property="article:author" content="By_Xb"><meta property="article:tag" content="Spring-Boot"><meta property="article:tag" content="Docker"><meta property="article:tag" content="springmvc"><meta property="article:tag" content="Java"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/320"><link rel="shortcut icon" href="/img/siteicon/favicon-32x32.png"><link rel="canonical" href="https://wtnl.xyz/2023/06/23/%E6%91%98%E6%96%87%E7%AC%94%E8%AE%B0%E4%B8%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"top-center"},
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
}
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"摘文笔记_常用技术一",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2021-06-06 10:05:40"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link defer="defer" rel="stylesheet" href="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/css/extrastyle.css" media="defer" onload='this.media="all"'><link async rel="stylesheet" href="/css/foter.css" media="defer" onload='this.media="all"'><link async rel="stylesheet" href="/css/myblog.css" media="defer" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xingjiahui/modify@2.0.0/pace/themes/pink/pace-theme-flash.css"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="By_Xb" type="application/atom+xml"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images2/author.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa fa-spinner"></i> <span>追番</span></a></li><li><a class="site-page child" href="/gallery/index.htm"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-cloud"></i> <span>动态</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/320)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">By_Xb</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i> <span>清单</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa fa-spinner"></i> <span>追番</span></a></li><li><a class="site-page child" href="/gallery/index.htm"><i class="fa-fw fas fa-images"></i> <span>相册</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-cloud"></i> <span>动态</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">摘文笔记_常用技术一</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-23T06:47:58.937Z" title="发表于 2023-06-23 14:47:58">2023-06-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-06T02:05:40.000Z" title="更新于 2021-06-06 10:05:40">2021-06-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%90%8E%E7%AB%AF-%E7%AC%94%E8%AE%B0/">后端-笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>94分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="摘文笔记_常用技术一"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><div class="tip cogs"><ol><li>Log4j2使用以及异步性能 ,</li><li> Springboot全局异常处理 ,</li><li> Springboot自定义注解+拦截器实现敏感数据加解密 ,</li><li> Docker图形化工具 ,</li><li>SpringMVC:注解@ControllerAdvice的工作原理 ,</li><li> 出路重复请求并转发 ,</li><li>SpringAOP详解 ,</li><li>java8 Stream流失编程.</li></ol></div><h1 id="Log4j2使用以及异步性能"><a href="#Log4j2使用以及异步性能" class="headerlink" title="Log4j2使用以及异步性能"></a>Log4j2使用以及异步性能</h1><p>Logback 算是JAVA 里一个老牌的日志框架，从06年开始第一个版本，迭代至今也十几年了。不过logback最近一个稳定版本还停留在 2017 年，好几年都没有更新；logback的兄弟 slf4j 最近一个稳定版也是2017年，有点凉凉的意思。</p><p>而且 logback的异步性能实在拉跨，功能简陋，配置又繁琐，远不及Apache 的新一代日志框架 - Log4j2</p><p>目前来看，Log4j2 就是王者，其他日志框架都不是对手</p><h2 id="Log4j2简介"><a href="#Log4j2简介" class="headerlink" title="Log4j2简介"></a>Log4j2简介</h2><p>Apache Log4j 2是 Log4j(1) 的升级版，比它的祖先 Log4j 1. x 有了很大的改进，和logback对比有很大的改进。除了内部设计的调整外，主要有以下几点的大升级：</p><ul><li>更简化的配置</li><li>更强大的参数格式化</li><li>最夸张的异步性能</li></ul><p>Log4j 2中，分为API(log4j-api）和实现(log4j-core)两个模块。API 和slf4j 是一个类型，属于日志抽象/门面，而实现部分，才是Log4j 2的核心。</p><ul><li>org.apache.logging.log4j » log4j-api</li><li>org.apache.logging.log4j » log4j-core</li></ul><h2 id="最牛逼的性能"><a href="#最牛逼的性能" class="headerlink" title="最牛逼的性能"></a>最牛逼的性能</h2><h3 id="最强的异步性能"><a href="#最强的异步性能" class="headerlink" title="最强的异步性能"></a>最强的异步性能</h3><p>这个特性，算是Log4j2最强之处了。log4j2 在目前JAVA中的日志框架里，异步日志的性能是最高的，没有之一。</p><p>先来看一下，几种日志框架benchmark对比结果（log4j2官方测试结果）：</p><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605213907389.png" alt="image-20210605213907389"></p><p>从图上可以看出，log4j2的异步（全异步，非混合模式）下的性能，远超log4j1和logback，简直吊打。压力越大的情况下，吞吐上的差距就越大。在64线程测试下，log4j2的吞吐达到了180w+/s，而logback/log4j1只有不到20w，相差近十倍</p><h3 id="零GC（Garbage-free）"><a href="#零GC（Garbage-free）" class="headerlink" title="零GC（Garbage-free）"></a>零GC（Garbage-free）</h3><p>从2.6版本开始（2016年），log4j2 默认就以零GC模式运行了。什么叫零GC呢？就是不会由于log4j2而导致GC。</p><p>log4j2 中各种Message对象，字符串数组，字节数组等全部复用，不重复创建，大大减少了无用对象的创建，从而做到“零GC”。</p><h3 id="更高性能-I-O-写入的支持"><a href="#更高性能-I-O-写入的支持" class="headerlink" title="更高性能 I/O 写入的支持"></a>更高性能 I/O 写入的支持</h3><p>log4j 还提供了一个MemoryMappedFileAppender，I/O 部分使用MemoryMappedFile来实现，可以得到极高的I/O性能。不过在使用MemoryMappedFileAppender之前，得确定你足够了解MemoryMappedFile的相关知识，否则不要轻易使用呦。</p><h2 id="更强大的参数格式化"><a href="#更强大的参数格式化" class="headerlink" title="更强大的参数格式化"></a>更强大的参数格式化</h2><p>API模块和slf4j相比，提供了更丰富的参数格式化功能。</p><h3 id="使用-占位符格式化参数"><a href="#使用-占位符格式化参数" class="headerlink" title="使用{}占位符格式化参数"></a>使用<code>&#123;&#125;</code>占位符格式化参数</h3><p>在slf4j里，我们可以用<code>&#123;&#125;</code>的方式来实现“format”的功能（参数会直接toString替换占位符），像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;Logging in user &#123;&#125; with birthday &#123;&#125;&quot;</span>, user.getName(), user.getBirthdayCalendar());</span><br></pre></td></tr></table></figure><h3 id="使用String-format的形式格式化参数"><a href="#使用String-format的形式格式化参数" class="headerlink" title="使用String.format的形式格式化参数"></a>使用String.format的形式格式化参数</h3><p>log4j2 中除了支持<code>&#123;&#125;</code>的参数占位符，还支持String.format的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getFormatterLogger(<span class="string">&quot;Foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;Logging in user %s with birthday %s&quot;</span>, user.getName(), user.getBirthdayCalendar());</span><br><span class="line">logger.debug(<span class="string">&quot;Logging in user %1$s with birthday %2$tm %2$te,%2$tY&quot;</span>, user.getName(), user.getBirthdayCalendar());</span><br><span class="line">logger.debug(<span class="string">&quot;Integer.MAX_VALUE = %,d&quot;</span>, Integer.MAX_VALUE);</span><br><span class="line">logger.debug(<span class="string">&quot;Long.MAX_VALUE = %,d&quot;</span>, Long.MAX_VALUE);</span><br></pre></td></tr></table></figure><p>** 注意，如果想使用String.format的形式，需要使用<code>LogManager.getFormatterLogger</code>而不是<code>LogManager.getLogger</code>**</p><h3 id="使用logger-printf格式化参数"><a href="#使用logger-printf格式化参数" class="headerlink" title="使用logger.printf格式化参数"></a>使用logger.printf格式化参数</h3><p>log4j2 的 Logger接口中，还有一个<code>printf</code>方法，无需创建<code>LogManager.getFormatterLogger</code>，就可以使用<code>String.format</code>的形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">logger.printf(Level.INFO, <span class="string">&quot;Logging in user %1$s with birthday %2$tm %2$te,%2$tY&quot;</span>, user.getName(), user.getBirthdayCalendar());</span><br><span class="line"></span><br><span class="line">logger.debug(<span class="string">&quot;Opening connection to &#123;&#125;...&quot;</span>, someDataSource);</span><br></pre></td></tr></table></figure><h3 id="“惰性”打日志（lazy-logging）"><a href="#“惰性”打日志（lazy-logging）" class="headerlink" title="“惰性”打日志（lazy logging）"></a>“惰性”打日志（lazy logging）</h3><p>这个功能虽然小，但非常实用。</p><p>在某些业务流程里，为了留根或追溯问题，需要完整的打印入参，一般是把入参给用JSON/XML序列化后用debug级别打印：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;入参报文：&#123;&#125;&quot;</span>,JSON.toJSONString(policyDTO));</span><br></pre></td></tr></table></figure><p>如果需要追溯问题时，会将系统的日志级别调到debug/trace，这样就可以打印。但是这里有个问题，虽然在info级别下debug不会输出内容，但JSON.toJSONString()这个序列化的代码一定会执行，严重影响正常流程下的执行效率。</p><p>我们期望的结果是info级别下，连序列化都不执行。这里可以通过<code>isDebugEnable</code>来判断当前配置下debug级别是否可以输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;入参报文：&#123;&#125;&quot;</span>,JSON.toJSONString(policyDTO));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样虽然可以避免不必要的序列化，但每个地方都这么写还是有点难受的，一行变成了三行。</p><p>log4j2 的 logger 对象，提供了一系列lambda的支持，通过这些接口可以实现“惰性”打日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(String message, Supplier&lt;?&gt;... paramSuppliers)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">info</span><span class="params">(String message, Supplier&lt;?&gt;... paramSuppliers)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">trace</span><span class="params">(String message, Supplier&lt;?&gt;... paramSuppliers)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">error</span><span class="params">(String message, Supplier&lt;?&gt;... paramSuppliers)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于下面的先判断，后打印</span></span><br><span class="line">logger.debug(<span class="string">&quot;入参报文：&#123;&#125;&quot;</span>,() -&gt; JSON.toJSONString(policyDTO));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(logger.isDebugEnabled())&#123;</span><br><span class="line">    logger.debug(<span class="string">&quot;入参报文：&#123;&#125;&quot;</span>,JSON.toJSONString(policyDTO));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种 Supplier + Lambda 的形式，等同于上面的先判断 isDebugEnable 然后打印，三行的代码变成了一行。嗯，真香。</p><h2 id="更简化的配置"><a href="#更简化的配置" class="headerlink" title="更简化的配置"></a>更简化的配置</h2><p>Log4j 2 同时支持XML/JSON/YML/Properties 四种形式的配置文件，不过最主流的还是XML的方式，最直观。</p><p>来看一下logback和log4j2的配置文件对比，同样功能的配置下：</p><h3 id="logback-xml"><a href="#logback-xml" class="headerlink" title="logback.xml"></a>logback.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> = <span class="string">&quot;File&quot;</span> <span class="attr">class</span>= <span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>logs/app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>logs/archives/app-%d&#123;yyyy-MM-dd&#125;.log.gz<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--一天内大于size就单独分隔--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>1 GB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;File&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="log4j2-xml"><a href="#log4j2-xml" class="headerlink" title="log4j2.xml"></a>log4j2.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">xmlns:xi</span>=<span class="string">&quot;http://www.w3.org/2001/XInclude&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">status</span>=<span class="string">&quot;warn&quot;</span> <span class="attr">name</span>=<span class="string">&quot;XInclude&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;File&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;logs/app.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;logs/archives/app-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %5p [%t] %-40.40c&#123;1.&#125; : %m%n&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> /&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--一天内大于size就单独分隔--&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 GB&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;File&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在log4j2中，appender的配置从使用 Appender 实现名即标签名的形式，语法上更简洁一些：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;File&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 等同于logback中的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span> = <span class="string">&quot;File&quot;</span> <span class="attr">class</span>= <span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="与其他日志抽象-门面适配"><a href="#与其他日志抽象-门面适配" class="headerlink" title="与其他日志抽象/门面适配"></a>与其他日志抽象/门面适配</h2><p>log4j2 由于拆分为 API 和 实现两部分，所以可能也需要和其他日志框架进行适配，详细的日志框架适配方案请参考我的另一篇文章《【可能是全网最全的】JAVA日志框架适配/冲突解决方案》<img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214002050.png" alt="image-20210605214002050"></p><h2 id="其他的特点"><a href="#其他的特点" class="headerlink" title="其他的特点"></a>其他的特点</h2><ol><li>异步队列使用高性能队列 - **LMAX Disruptor **</li><li>Appender丰富，有JMS/JPA/KAFKA/Http/MONGODB/CouchDB/Socket/Script等各种Appender的支持</li><li>支持自定义日志级别</li><li>……</li></ol><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>终于介绍完了Log4j2的强大，现在来介绍下Log4j2的基本使用。</p><h3 id="引用log4j2的maven依赖"><a href="#引用log4j2的maven依赖" class="headerlink" title="引用log4j2的maven依赖"></a>引用log4j2的maven依赖</h3><p>log4j-api在log4j-core中已经有依赖了，直接依赖core即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意，引用log4j2时，需要注意项目中是否有多套日志框架共存/冲突，需要适配的问题。细节请参考上面的与其他日志抽象/门面适配</p><h3 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h3><p>首先是配置文件，默认的配置文件路径为：<code>classpath:log4j2.xml</code>（推荐使用xml）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">xmlns:xi</span>=<span class="string">&quot;http://www.w3.org/2001/XInclude&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">status</span>=<span class="string">&quot;warn&quot;</span> <span class="attr">name</span>=<span class="string">&quot;XInclude&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %5p [%t] %-40.40c&#123;1.&#125; : %m%n&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 输出到控制台，仅在本地开发环境使用 --&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--输出到日志文件，滚动分割日志文件，自动打包gz--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;File&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;logs/app.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;logs/archives/app-%d&#123;yyyy-MM-dd&#125;-%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                 <span class="comment">&lt;!--默认一天一个文件--&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> /&gt;</span></span><br><span class="line">                  <span class="comment">&lt;!--一天内大于size就单独分隔--&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 GB&quot;</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 添加你的自定义logger，一般用于区分包名的日志，不同包名不同的级别/appender --&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- additivity 意思是，调用完当前appender，是否继续调用parent logger appender，默认true--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">&quot;your logger/package name&quot;</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--默认的Root Logger 级别--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--这里需要区分下环境（配合maven profile之类的）--&gt;</span></span><br><span class="line">           <span class="comment">&lt;!-- 开发环境使用Console Appender，生产环境使用File Appender --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;File&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="XML配置文件语法"><a href="#XML配置文件语法" class="headerlink" title="XML配置文件语法"></a>XML配置文件语法</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>;</span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;name1&quot;</span>&gt;</span>value<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;name2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value2&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>  <span class="attr">...</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span>  <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Logger</span> <span class="attr">name</span>=<span class="string">&quot;name1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span>  <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Logger</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;level&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建Logger"><a href="#创建Logger" class="headerlink" title="创建Logger"></a>创建Logger</h3><p>直接使用log4j2的api：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.logging.log4j.LogManager;</span><br><span class="line">import org.apache.logging.log4j.Logger;</span><br><span class="line"></span><br><span class="line">Logger logger = LogManager.getLogger(Log4j2Test.class);</span><br><span class="line">logger.error(...);</span><br><span class="line">logger.warn(...);</span><br><span class="line">logger.info(...);</span><br><span class="line">logger.debug(...);</span><br><span class="line">logger.trace(...);</span><br></pre></td></tr></table></figure><p>如果是配合slf4j使用也是可以的，只需要按照前面说的，提前做好适配，然后使用slf4j的api即可。不过如果是新系统的话，建议直接上log4j2的api吧，可以享受所有log4j2的功能，使用slf4j之类的api时，上面说的参数格式化之类的功能就无法使用了。</p><h3 id="全异步配置（重要！！）"><a href="#全异步配置（重要！！）" class="headerlink" title="全异步配置（重要！！）"></a>全异步配置（重要！！）</h3><p>推荐配置log4j2 全异步（all async），只需要在主程序代码开头，加一句系统属性的代码：：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(<span class="string">&quot;Log4jContextSelector&quot;</span>, <span class="string">&quot;org.apache.logging.log4j.core.async.AsyncLoggerContextSelector&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Log4j2 如今性能最强，功能最强，而且持续更新维护。还在等什么？是时候替换你的logback/log4j1了！</p><h1 id="SpringBoot-的全局异常处理"><a href="#SpringBoot-的全局异常处理" class="headerlink" title="SpringBoot 的全局异常处理"></a>SpringBoot 的全局异常处理</h1><p>本篇文章主要介绍的是SpringBoot项目进行全局异常的处理。</p><h2 id="SpringBoot全局异常准备"><a href="#SpringBoot全局异常准备" class="headerlink" title="SpringBoot全局异常准备"></a>SpringBoot全局异常准备</h2><p>说明：如果想直接获取工程那么可以直接跳到底部，通过链接下载工程代码。</p><h3 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h3><p>环境要求<br>JDK：1.8<br>SpringBoot：1.5.17.RELEASE</p><p>首先还是Maven的相关依赖:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.17.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Spring Boot Web 依赖 核心 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- Spring Boot Test 依赖 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.41<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置文件这块基本不需要更改，全局异常的处理只需在代码中实现即可。</p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>SpringBoot的项目已经对有一定的异常处理了，但是对于我们开发者而言可能就不太合适了，因此我们需要对这些异常进行统一的捕获并处理。SpringBoot中有一个<code>ControllerAdvice</code>的注解，使用该注解表示开启了全局异常的捕获，我们只需在自定义一个方法使用<code>ExceptionHandler</code>注解然后定义捕获异常的类型即可对这些捕获的异常进行统一的处理。</p><p>我们根据下面的这个示例来看该注解是如何使用吧。</p><p>示例代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value =Exception.class)</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">exceptionHandler</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;未知异常！原因是:&quot;</span>+e);</span><br><span class="line">        <span class="keyword">return</span> e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的示例中，我们对捕获的异常进行简单的二次处理，返回异常的信息，虽然这种能够让我们知道异常的原因，但是在很多的情况下来说，可能还是不够人性化，不符合我们的要求。那么我们这里可以通过自定义的异常类以及枚举类来实现我们想要的那种数据吧。</p><p>自定义基础接口类</p><p>首先定义一个基础的接口类，自定义的错误描述枚举类需实现该接口。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseErrorInfoInterface</span> &#123;</span><br><span class="line">    <span class="comment">/** 错误码*/</span></span><br><span class="line">  String <span class="title function_">getResultCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** 错误描述*/</span></span><br><span class="line">  String <span class="title function_">getResultMsg</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义枚举类</p><p>然后我们这里在自定义一个枚举类，并实现该接口。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">CommonEnum</span> <span class="keyword">implements</span> <span class="title class_">BaseErrorInfoInterface</span> &#123;</span><br><span class="line"> <span class="comment">// 数据操作错误定义</span></span><br><span class="line"> SUCCESS(<span class="string">&quot;200&quot;</span>, <span class="string">&quot;成功!&quot;</span>), </span><br><span class="line"> BODY_NOT_MATCH(<span class="string">&quot;400&quot;</span>,<span class="string">&quot;请求的数据格式不符!&quot;</span>),</span><br><span class="line"> SIGNATURE_NOT_MATCH(<span class="string">&quot;401&quot;</span>,<span class="string">&quot;请求的数字签名不匹配!&quot;</span>),</span><br><span class="line"> NOT_FOUND(<span class="string">&quot;404&quot;</span>, <span class="string">&quot;未找到该资源!&quot;</span>), </span><br><span class="line"> INTERNAL_SERVER_ERROR(<span class="string">&quot;500&quot;</span>, <span class="string">&quot;服务器内部错误!&quot;</span>),</span><br><span class="line"> SERVER_BUSY(<span class="string">&quot;503&quot;</span>,<span class="string">&quot;服务器正忙，请稍后再试!&quot;</span>)</span><br><span class="line"> ;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** 错误码 */</span></span><br><span class="line"> <span class="keyword">private</span> String resultCode;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/** 错误描述 */</span></span><br><span class="line"> <span class="keyword">private</span> String resultMsg;</span><br><span class="line"></span><br><span class="line"> CommonEnum(String resultCode, String resultMsg) &#123;</span><br><span class="line">  <span class="built_in">this</span>.resultCode = resultCode;</span><br><span class="line">  <span class="built_in">this</span>.resultMsg = resultMsg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getResultCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resultCode;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getResultMsg</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> resultMsg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义异常类</p><p>然后我们在来自定义一个异常类，用于处理我们发生的业务异常。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BizException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 错误码</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">protected</span> String errorCode;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 错误信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">protected</span> String errorMsg;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">(BaseErrorInfoInterface errorInfoInterface)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(errorInfoInterface.getResultCode());</span><br><span class="line">  <span class="built_in">this</span>.errorCode = errorInfoInterface.getResultCode();</span><br><span class="line">  <span class="built_in">this</span>.errorMsg = errorInfoInterface.getResultMsg();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">(BaseErrorInfoInterface errorInfoInterface, Throwable cause)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(errorInfoInterface.getResultCode(), cause);</span><br><span class="line">  <span class="built_in">this</span>.errorCode = errorInfoInterface.getResultCode();</span><br><span class="line">  <span class="built_in">this</span>.errorMsg = errorInfoInterface.getResultMsg();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">(String errorMsg)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(errorMsg);</span><br><span class="line">  <span class="built_in">this</span>.errorMsg = errorMsg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">(String errorCode, String errorMsg)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(errorCode);</span><br><span class="line">  <span class="built_in">this</span>.errorCode = errorCode;</span><br><span class="line">  <span class="built_in">this</span>.errorMsg = errorMsg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">BizException</span><span class="params">(String errorCode, String errorMsg, Throwable cause)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(errorCode, cause);</span><br><span class="line">  <span class="built_in">this</span>.errorCode = errorCode;</span><br><span class="line">  <span class="built_in">this</span>.errorMsg = errorMsg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getErrorCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errorCode;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setErrorCode</span><span class="params">(String errorCode)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.errorCode = errorCode;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getErrorMsg</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errorMsg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setErrorMsg</span><span class="params">(String errorMsg)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.errorMsg = errorMsg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> errorMsg;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> Throwable <span class="title function_">fillInStackTrace</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义数据格式</p><p>顺便这里我们定义一下数据的传输格式。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResultBody</span> &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 响应代码</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String code;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 响应消息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 响应结果</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> Object result;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ResultBody</span><span class="params">()</span> &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">ResultBody</span><span class="params">(BaseErrorInfoInterface errorInfo)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.code = errorInfo.getResultCode();</span><br><span class="line">  <span class="built_in">this</span>.message = errorInfo.getResultMsg();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> code;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(String code)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.code = code;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> message;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> Object <span class="title function_">getResult</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResult</span><span class="params">(Object result)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.result = result;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 成功</span></span><br><span class="line"><span class="comment">  * </span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ResultBody <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> success(<span class="literal">null</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 成功</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> data</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ResultBody <span class="title function_">success</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">  <span class="type">ResultBody</span> <span class="variable">rb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultBody</span>();</span><br><span class="line">  rb.setCode(CommonEnum.SUCCESS.getResultCode());</span><br><span class="line">  rb.setMessage(CommonEnum.SUCCESS.getResultMsg());</span><br><span class="line">  rb.setResult(data);</span><br><span class="line">  <span class="keyword">return</span> rb;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ResultBody <span class="title function_">error</span><span class="params">(BaseErrorInfoInterface errorInfo)</span> &#123;</span><br><span class="line">  <span class="type">ResultBody</span> <span class="variable">rb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultBody</span>();</span><br><span class="line">  rb.setCode(errorInfo.getResultCode());</span><br><span class="line">  rb.setMessage(errorInfo.getResultMsg());</span><br><span class="line">  rb.setResult(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> rb;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ResultBody <span class="title function_">error</span><span class="params">(String code, String message)</span> &#123;</span><br><span class="line">  <span class="type">ResultBody</span> <span class="variable">rb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultBody</span>();</span><br><span class="line">  rb.setCode(code);</span><br><span class="line">  rb.setMessage(message);</span><br><span class="line">  rb.setResult(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> rb;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 失败</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> ResultBody <span class="title function_">error</span><span class="params">( String message)</span> &#123;</span><br><span class="line">  <span class="type">ResultBody</span> <span class="variable">rb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResultBody</span>();</span><br><span class="line">  rb.setCode(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">  rb.setMessage(message);</span><br><span class="line">  rb.setResult(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> rb;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> JSONObject.toJSONString(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义全局异常处理类</p><p>最后我们在来编写一个自定义全局异常处理的类。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(GlobalExceptionHandler.class);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 处理自定义的业务异常</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = BizException.class)</span>  </span><br><span class="line">    <span class="meta">@ResponseBody</span>  </span><br><span class="line"> <span class="keyword">public</span>  ResultBody <span class="title function_">bizExceptionHandler</span><span class="params">(HttpServletRequest req, BizException e)</span>&#123;</span><br><span class="line">     logger.error(<span class="string">&quot;发生业务异常！原因是：&#123;&#125;&quot;</span>,e.getErrorMsg());</span><br><span class="line">     <span class="keyword">return</span> ResultBody.error(e.getErrorCode(),e.getErrorMsg());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 处理空指针的异常</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@ExceptionHandler(value =NullPointerException.class)</span></span><br><span class="line"> <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="keyword">public</span> ResultBody <span class="title function_">exceptionHandler</span><span class="params">(HttpServletRequest req, NullPointerException e)</span>&#123;</span><br><span class="line">  logger.error(<span class="string">&quot;发生空指针异常！原因是:&quot;</span>,e);</span><br><span class="line">  <span class="keyword">return</span> ResultBody.error(CommonEnum.BODY_NOT_MATCH);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 处理其他异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value =Exception.class)</span></span><br><span class="line"> <span class="meta">@ResponseBody</span></span><br><span class="line"> <span class="keyword">public</span> ResultBody <span class="title function_">exceptionHandler</span><span class="params">(HttpServletRequest req, Exception e)</span>&#123;</span><br><span class="line">     logger.error(<span class="string">&quot;未知异常！原因是:&quot;</span>,e);</span><br><span class="line">        <span class="keyword">return</span> ResultBody.error(CommonEnum.INTERNAL_SERVER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里我们只是用于做全局异常处理的功能实现以及测试，所以这里我们只需在添加一个实体类和一个控制层类即可。</p><p>实体类</p><p>又是万能的用户表 (<em>▽</em>)</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"> <span class="comment">/** 编号 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="comment">/** 姓名 */</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">/** 年龄 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> id;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.id = id;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> age;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> JSONObject.toJSONString(<span class="built_in">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller 控制层</p><p>控制层这边也比较简单，使用Restful风格实现的CRUD功能，不同的是这里我故意弄出了一些异常，好让这些异常被捕获到然后处理。这些异常中，有自定义的异常抛出，也有空指针的异常抛出，当然也有不可预知的异常抛出(这里我用类型转换异常代替)，那么我们在完成代码编写之后，看看这些异常是否能够被捕获处理成功吧！</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/api&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRestController</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;开始新增...&quot;</span>);</span><br><span class="line">     <span class="comment">//如果姓名为空就手动抛出一个自定义的异常！</span></span><br><span class="line">        <span class="keyword">if</span>(user.getName()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">BizException</span>(<span class="string">&quot;-1&quot;</span>,<span class="string">&quot;用户姓名不能为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;开始更新...&quot;</span>);</span><br><span class="line">       <span class="comment">//这里故意造成一个空指针的异常，并且不进行处理</span></span><br><span class="line">        String str=<span class="literal">null</span>;</span><br><span class="line">        str.equals(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>  &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始删除...&quot;</span>);</span><br><span class="line">        <span class="comment">//这里故意造成一个异常，并且不进行处理</span></span><br><span class="line">        Integer.parseInt(<span class="string">&quot;abc123&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findByUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;开始查询...&quot;</span>);</span><br><span class="line">        List&lt;User&gt; userList =<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        User user2=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setId(<span class="number">1L</span>);</span><br><span class="line">        user2.setName(<span class="string">&quot;xuwujing&quot;</span>);</span><br><span class="line">        user2.setAge(<span class="number">18</span>);</span><br><span class="line">        userList.add(user2);</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>App 入口</p><p>和普通的SpringBoot项目基本一样。</p><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span></span><br><span class="line">    &#123;</span><br><span class="line">  SpringApplication.run(App.class, args);</span><br><span class="line">  System.out.println(<span class="string">&quot;程序正在运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p>我们成功启动该程序之后，使用Postman工具来进行接口测试。</p><p>首先进行查询，查看程序正常运行是否ok，使用GET 方式进行请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET [http://localhost:8181/api/user](http://localhost:8181/api/user)</span><br></pre></td></tr></table></figure><p>返回参数为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;:1,&quot;name&quot;:&quot;xuwujing&quot;,&quot;age&quot;:18&#125;</span><br></pre></td></tr></table></figure><p>示例图:<img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214135664.png" alt="image-20210605214135664"></p><p>可以看到程序正常返回，并没有因自定义的全局异常而影响。</p><p>然后我们再来测试下自定义的异常是否能够被正确的捕获并处理。</p><p>使用POST方式进行请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST [http://localhost:8181/api/user](http://localhost:8181/api/user)</span><br></pre></td></tr></table></figure><p>Body参数为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;:1,&quot;age&quot;:18&#125;</span><br></pre></td></tr></table></figure><p>返回参数为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;code&quot;:&quot;-1&quot;,&quot;message&quot;:&quot;用户姓名不能为空！&quot;,&quot;result&quot;:null&#125;</span><br></pre></td></tr></table></figure><p>示例图:</p><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214310706.png" alt="image-20210605214310706"></p><p>可以看出将我们抛出的异常进行数据封装，然后将异常返回出来。</p><p>然后我们再来测试下空指针异常是否能够被正确的捕获并处理。在自定义全局异常中，我们除了定义空指针的异常处理，也定义最高级别之一的Exception异常，那么这里发生了空指针异常之后，它是回优先使用哪一个呢？这里我们来测试下。</p><p>使用PUT方式进行请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT [http://localhost:8181/api/user](http://localhost:8181/api/user)</span><br></pre></td></tr></table></figure><p>Body参数为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;:1,&quot;age&quot;:18&#125;</span><br></pre></td></tr></table></figure><p>返回参数为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;code&quot;:&quot;400&quot;,&quot;message&quot;:&quot;请求的数据格式不符!&quot;,&quot;result&quot;:null&#125;</span><br></pre></td></tr></table></figure><p>示例图:<img src="https://mmbiz.qpic.cn/mmbiz_png/8Jeic82Or04lzqxialA7dsHlx17Amiatd40jzOOLraB4nF3mQcz1gTeUtOQPCyetCZryCW2ic7JJquKd6cCw87kD0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>我们可以看到这里的的确是返回空指针的异常护理，可以得出全局异常处理优先处理子类的异常。</p><p>那么我们在来试试未指定其异常的处理，看该异常是否能够被捕获。</p><p>使用DELETE方式进行请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE [http://localhost:8181/api/user](http://localhost:8181/api/user)</span><br></pre></td></tr></table></figure><p>Body参数为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;:1&#125;</span><br></pre></td></tr></table></figure><p>返回参数为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;code&quot;:&quot;500&quot;,&quot;message&quot;:&quot;服务器内部错误!&quot;,&quot;result&quot;:null&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214331619.png" alt="image-20210605214331619"></p><p>这里可以看到它使用了我们在自定义全局异常处理类中的Exception异常处理的方法。到这里，测试就结束了。顺便再说一下，自义定全局异常处理除了可以处理上述的数据格式之外，也可以处理页面的跳转，只需在新增的异常方法的返回处理上填写该跳转的路径并不使用<code>ResponseBody</code> 注解即可。细心的同学也许发现了在<code>GlobalExceptionHandler</code>类中使用的是<code>ControllerAdvice</code>注解，而非<code>RestControllerAdvice</code>注解，如果是用的<code>RestControllerAdvice</code>注解，它会将数据自动转换成JSON格式，这种于<code>Controller</code>和<code>RestController</code>类似，所以我们在使用全局异常处理的之后可以进行灵活的选择处理。</p><h1 id="在SpringBoot项目中，自定义注解-拦截器优雅的实现敏感数据的加解密！"><a href="#在SpringBoot项目中，自定义注解-拦截器优雅的实现敏感数据的加解密！" class="headerlink" title="在SpringBoot项目中，自定义注解+拦截器优雅的实现敏感数据的加解密！"></a>在SpringBoot项目中，自定义注解+拦截器优雅的实现敏感数据的加解密！</h1><p>在实际生产项目中，经常需要对如身份证信息、手机号、真实姓名等的敏感数据进行加密数据库存储，但在业务代码中对敏感信息进行手动加解密则十分不优雅，甚至会存在错加密、漏加密、业务人员需要知道实际的加密规则等的情况。</p><p>本文将介绍使用springboot+mybatis拦截器+自定义注解的形式对敏感数据进行存储前拦截加密的详细过程。</p><h2 id="一、什么是Mybatis-Plugin"><a href="#一、什么是Mybatis-Plugin" class="headerlink" title="一、什么是Mybatis Plugin"></a>一、什么是Mybatis Plugin</h2><p>在mybatis官方文档中，对于Mybatis plugin的的介绍是这样的：</p><p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语句执行拦截</span></span><br><span class="line">Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数获取、设置时进行拦截</span></span><br><span class="line">ParameterHandler (getParameterObject, setParameters)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对返回结果进行拦截</span></span><br><span class="line">ResultSetHandler (handleResultSets, handleOutputParameters)</span><br><span class="line"></span><br><span class="line"><span class="comment">//sql语句拦截</span></span><br><span class="line">StatementHandler (prepare, parameterize, batch, update, query)</span><br></pre></td></tr></table></figure><p>简而言之，即在执行sql的整个周期中，我们可以任意切入到某一点对sql的参数、sql执行结果集、sql语句本身等进行切面处理。基于这个特性，我们便可以使用其对我们需要进行加密的数据进行切面统一加密处理了（分页插件 pageHelper 就是这样实现数据库分页查询的）。</p><h2 id="二、实现基于注解的敏感信息加解密拦截器"><a href="#二、实现基于注解的敏感信息加解密拦截器" class="headerlink" title="二、实现基于注解的敏感信息加解密拦截器"></a>二、实现基于注解的敏感信息加解密拦截器</h2><h3 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a>2.1 实现思路</h3><p>对于数据的加密与解密，应当存在两个拦截器对数据进行拦截操作</p><p>参照官方文档，因此此处我们应当使用ParameterHandler拦截器对入参进行加密</p><p>使用ResultSetHandler拦截器对出参进行解密操作。</p><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214403484.png" alt="image-20210605214403484"></p><p>目标需要加密、解密的字段可能需要灵活变更，此时我们定义一个注解，对需要加密的字段进行注解，那么便可以配合拦截器对需要的数据进行加密与解密操作了。</p><p>mybatis的interceptor接口有以下方法需要实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//主要参数拦截方法</span></span><br><span class="line">  Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//mybatis插件链</span></span><br><span class="line">  <span class="keyword">default</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;<span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//自定义插件配置文件方法</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-定义需要加密解密的敏感信息注解"><a href="#2-2-定义需要加密解密的敏感信息注解" class="headerlink" title="2.2 定义需要加密解密的敏感信息注解"></a>2.2 定义需要加密解密的敏感信息注解</h3><p>定义注解敏感信息类（如实体类POJO\PO）的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解敏感信息类的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.TYPE &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SensitiveData &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义注解敏感信息类中敏感字段的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解敏感信息类中敏感字段的注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Target(&#123; ElementType.Field &#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SensitiveField &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-定义加密接口及其实现类"><a href="#2-3-定义加密接口及其实现类" class="headerlink" title="2.3 定义加密接口及其实现类"></a>2.3 定义加密接口及其实现类</h3><p>定义加密接口，方便以后拓展加密方法（如AES加密算法拓展支持PBE算法，只需要注入时指定一下便可）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EncryptUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> declaredFields paramsObject所声明的字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramsObject   mapper中paramsType的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException 字段不可访问异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     &lt;T&gt; T <span class="title function_">encrypt</span><span class="params">(Field[] declaredFields, T paramsObject)</span> <span class="keyword">throws</span> IllegalAccessException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EncryptUtil 的AES加密实现类，此处AESUtil为自封装的AES加密工具，需要的小伙伴可以自行封装，本文不提供。（搜索公众号Java知音，回复“2021”，送你一份Java面试题宝典）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AESEncrypt</span> <span class="keyword">implements</span> <span class="title class_">EncryptUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AESUtil aesUtil;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> declaredFields paramsObject所声明的字段</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> paramsObject   mapper中paramsType的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException 字段不可访问异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">encrypt</span><span class="params">(Field[] declaredFields, T paramsObject)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            <span class="comment">//取出所有被EncryptDecryptField注解的字段</span></span><br><span class="line">            <span class="type">SensitiveField</span> <span class="variable">sensitiveField</span> <span class="operator">=</span> field.getAnnotation(SensitiveField.class);</span><br><span class="line">            <span class="keyword">if</span> (!Objects.isNull(sensitiveField)) &#123;</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> field.get(paramsObject);</span><br><span class="line">                <span class="comment">//暂时只实现String类型的加密</span></span><br><span class="line">                <span class="keyword">if</span> (object <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) object;</span><br><span class="line">                    <span class="comment">//加密  这里我使用自定义的AES加密工具</span></span><br><span class="line">                    field.set(paramsObject, aesUtil.encrypt(value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> paramsObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-实现入参加密拦截器"><a href="#2-4-实现入参加密拦截器" class="headerlink" title="2.4 实现入参加密拦截器"></a>2.4 实现入参加密拦截器</h3><p>Myabtis包中的org.apache.ibatis.plugin.Interceptor拦截器接口要求我们实现以下三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//核心拦截逻辑</span></span><br><span class="line">  Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//拦截器链</span></span><br><span class="line">  <span class="keyword">default</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;<span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//自定义配置文件操作</span></span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123; &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，参考官方文档的示例，我们自定义一个入参加密拦截器。</p><p>@Intercepts 注解开启拦截器，@Signature 注解定义拦截器的实际类型。</p><p><strong>@Signature中</strong></p><ul><li>type 属性指定当前拦截器使用StatementHandler 、ResultSetHandler、ParameterHandler，Executor的一种</li><li>method 属性指定使用以上四种类型的具体方法（可进入class内部查看其方法）。</li><li>args 属性指定预编译语句</li></ul><p>此处我们使用了 ParameterHandler.setParamters()方法，拦截mapper.xml中paramsType的实例（即在每个含有paramsType属性mapper语句中，都执行该拦截器，对paramsType的实例进行拦截处理）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加密拦截器</span></span><br><span class="line"><span class="comment"> * 注意<span class="doctag">@Component</span>注解一定要加上</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : tanzj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2020/1/19.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">        @Signature(type = ParameterHandler.class, method = &quot;setParameters&quot;, args = PreparedStatement.class),</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EncryptInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EncryptDecryptUtil encryptUtil;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EncryptInterceptor</span><span class="params">(EncryptDecryptUtil encryptUtil)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.encryptUtil = encryptUtil;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//@Signature 指定了 type= parameterHandler 后，这里的 invocation.getTarget() 便是parameterHandler </span></span><br><span class="line">        <span class="comment">//若指定ResultSetHandler ，这里则能强转为ResultSetHandler</span></span><br><span class="line">        <span class="type">ParameterHandler</span> <span class="variable">parameterHandler</span> <span class="operator">=</span> (ParameterHandler) invocation.getTarget();</span><br><span class="line">        <span class="comment">// 获取参数对像，即 mapper 中 paramsType 的实例</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">parameterField</span> <span class="operator">=</span> parameterHandler.getClass().getDeclaredField(<span class="string">&quot;parameterObject&quot;</span>);</span><br><span class="line">        parameterField.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//取出实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">parameterObject</span> <span class="operator">=</span> parameterField.get(parameterHandler);</span><br><span class="line">        <span class="keyword">if</span> (parameterObject != <span class="literal">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; parameterObjectClass = parameterObject.getClass();</span><br><span class="line">            <span class="comment">//校验该实例的类是否被@SensitiveData所注解</span></span><br><span class="line">            <span class="type">SensitiveData</span> <span class="variable">sensitiveData</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(parameterObjectClass, SensitiveData.class);</span><br><span class="line">            <span class="keyword">if</span> (Objects.nonNull(sensitiveData)) &#123;</span><br><span class="line">                <span class="comment">//取出当前当前类所有字段，传入加密方法</span></span><br><span class="line">                Field[] declaredFields = parameterObjectClass.getDeclaredFields();</span><br><span class="line">                encryptUtil.encrypt(declaredFields, parameterObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 切记配置，否则当前拦截器不会加入拦截器链</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(o, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//自定义配置写入，没有自定义配置的可以直接置空此方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此完成自定义加密拦截加密。</p><h3 id="2-5-定义解密接口及其实现类"><a href="#2-5-定义解密接口及其实现类" class="headerlink" title="2.5 定义解密接口及其实现类"></a>2.5 定义解密接口及其实现类</h3><p>解密接口，其中result为mapper.xml中resultType的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DecryptUtil</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result resultType的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException 字段不可访问异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     &lt;T&gt; T <span class="title function_">decrypt</span><span class="params">(T result)</span> <span class="keyword">throws</span> IllegalAccessException;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解密接口AES工具解密实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AESDecrypt</span> <span class="keyword">implements</span> <span class="title class_">DecryptUtil</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AESUtil aesUtil;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result resultType的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> T</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalAccessException 字段不可访问异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">decrypt</span><span class="params">(T result)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">        <span class="comment">//取出resultType的类</span></span><br><span class="line">        Class&lt;?&gt; resultClass = result.getClass();</span><br><span class="line">        Field[] declaredFields = resultClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            <span class="comment">//取出所有被EncryptDecryptField注解的字段</span></span><br><span class="line">            <span class="type">SensitiveField</span> <span class="variable">sensitiveField</span> <span class="operator">=</span> field.getAnnotation(SensitiveField.class);</span><br><span class="line">            <span class="keyword">if</span> (!Objects.isNull(sensitiveField)) &#123;</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> field.get(result);</span><br><span class="line">                <span class="comment">//只支持String的解密</span></span><br><span class="line">                <span class="keyword">if</span> (object <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) object;</span><br><span class="line">                    <span class="comment">//对注解的字段进行逐一解密</span></span><br><span class="line">                    field.set(result, aesUtil.decrypt(value));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-定义出参解密拦截器"><a href="#2-6-定义出参解密拦截器" class="headerlink" title="2.6 定义出参解密拦截器"></a>2.6 定义出参解密拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Intercepts(&#123;</span></span><br><span class="line"><span class="meta">        @Signature(type = ResultSetHandler.class, method = &quot;handleResultSets&quot;, args = &#123;Statement.class&#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecryptInterceptor</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DecryptUtil aesDecrypt;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//取出查询的结果</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">resultObject</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(resultObject)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//基于selectList</span></span><br><span class="line">        <span class="keyword">if</span> (resultObject <span class="keyword">instanceof</span> ArrayList) &#123;</span><br><span class="line">            <span class="type">ArrayList</span> <span class="variable">resultList</span> <span class="operator">=</span> (ArrayList) resultObject;</span><br><span class="line">            <span class="keyword">if</span> (!CollectionUtils.isEmpty(resultList) &amp;&amp; needToDecrypt(resultList.get(<span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Object result : resultList) &#123;</span><br><span class="line">                    <span class="comment">//逐一解密</span></span><br><span class="line">                    aesDecrypt.decrypt(result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//基于selectOne</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (needToDecrypt(resultObject)) &#123;</span><br><span class="line">                aesDecrypt.decrypt(resultObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resultObject;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">needToDecrypt</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        Class&lt;?&gt; objectClass = object.getClass();</span><br><span class="line">        <span class="type">SensitiveData</span> <span class="variable">sensitiveData</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(objectClass, SensitiveData.class);</span><br><span class="line">        <span class="keyword">return</span> Objects.nonNull(sensitiveData);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">plugin</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Plugin.wrap(target, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此完成解密拦截器的配置工作。</p><h2 id="3、注解实体类中需要加解密的字段"><a href="#3、注解实体类中需要加解密的字段" class="headerlink" title="3、注解实体类中需要加解密的字段"></a>3、注解实体类中需要加解密的字段</h2><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214516184.png" alt="图片"></p><p>此时在mapper中，指定paramType=User resultType=User 便可实现脱离业务层，基于mybatis拦截器的加解密操作。</p><h1 id="Docker-图形化工具：Portainer"><a href="#Docker-图形化工具：Portainer" class="headerlink" title="Docker 图形化工具：Portainer"></a>Docker 图形化工具：Portainer</h1><h2 id="一-Docker图形化工具"><a href="#一-Docker图形化工具" class="headerlink" title="一.Docker图形化工具"></a>一.Docker图形化工具</h2><p>docker 图形页面管理工具常用的有三种，DockerUI ，Portainer ，Shipyard 。DockerUI 是 Portainer 的前身，这三个工具通过docker api来获取管理的资源信息。</p><p>平时我们常常对着shell对着这些命令行客户端，审美会很疲劳，如果有漂亮的图形化界面可以直观查看docker资源信息，也是非常方便的。</p><p>今天我们就搭建单机版的三种常用图形页面管理工具。这三种图形化管理工具以Portainer最为受欢迎。</p><h2 id="二-DockerUI"><a href="#二-DockerUI" class="headerlink" title="二.DockerUI"></a>二.DockerUI</h2><p>轻量级图形页面管理之DockerUI</p><p>1.查看dockerui镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker search dockerui</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><p>2.选择喜欢的dockerui风格镜像，下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker pull abh1nav/dockerui</span><br></pre></td></tr></table></figure><p>3.启动dockerui容器，这里需要注意带上privileged参数，提升权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run -d --privileged --name dockerui -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock abh1nav/dockerui</span><br></pre></td></tr></table></figure><p>前往网页查看之前，你需要打开服务器的9000端口： firewall-cmd –permanent –zone=public –add-port=9000/tcpfirewall-cmd –reload</p><p>4.浏览器查看dockerui：<a target="_blank" rel="noopener" href="http://192.168.2.119:9000/">http://192.168.2.119:9000</a> 或者 curl <a target="_blank" rel="noopener" href="http://192.168.2.119:9000/">http://192.168.2.119:9000</a></p><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214545816.png" alt="image-20210605214545816"></p><h2 id="三-Shipyard"><a href="#三-Shipyard" class="headerlink" title="三.Shipyard"></a>三.Shipyard</h2><p>轻量级图形页面管理之Shipyard</p><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214608923.png" alt="image-20210605214608923"></p><h2 id="四-Portainer"><a href="#四-Portainer" class="headerlink" title="四.Portainer"></a>四.Portainer</h2><p>轻量级图形页面管理之Portainer</p><h4 id="1-查看portainer镜像"><a href="#1-查看portainer镜像" class="headerlink" title="1.查看portainer镜像"></a>1.查看portainer镜像</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker search portainer</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><h4 id="2-选择喜欢的portainer风格镜像，下载"><a href="#2-选择喜欢的portainer风格镜像，下载" class="headerlink" title="2.选择喜欢的portainer风格镜像，下载"></a>2.选择喜欢的portainer风格镜像，下载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull portainer/portainer</span><br></pre></td></tr></table></figure><h4 id="3-启动dockerui容器"><a href="#3-启动dockerui容器" class="headerlink" title="3.启动dockerui容器"></a>3.启动dockerui容器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker volume create portainer_data</span><br><span class="line">docker run -d -p 9000:9000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>-v /var/run/docker.sock:/var/run/docker.sock</code> ：把宿主机的Docker守护进程(Docker daemon)默认监听的Unix域套接字挂载到容器中；</li><li><code>-v portainer\_data:/data</code> ：把宿主机portainer_data数据卷挂载到容器/data目录；</li></ul><h4 id="4-web管理"><a href="#4-web管理" class="headerlink" title="4.web管理"></a>4.web管理</h4><p>1、登陆 <a href="http://x.x.x.x:9000，设置管理员账号和密码。">http://x.x.x.x:9000，设置管理员账号和密码。</a></p><p>2、单机版在新页面选择 Local 即可完成安装，集群选择Remote然后输入SWARM的IP地址，点击Connect完成安装。</p><p>浏览器访问 <a target="_blank" rel="noopener" href="http://192.168.2.119:9000/">http://192.168.2.119:9000</a> , 设置一个密码即可，点击创建用户</p><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214627660.png" alt="image-20210605214627660"></p><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214643133.png" alt="image-20210605214643133"></p><p>我们搭建的是单机版，直接选择Local ，点击连接</p><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214701580.png" alt="image-20210605214701580"></p><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214717308.png" alt="image-20210605214717308"></p><p>现在就可以使用了，点击Local进入仪表盘主页面。</p><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214738253.png" alt="image-20210605214738253"></p><p>容器页面</p><p><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/image-20210605214750869.png" alt="image-20210605214750869"></p><h1 id="SpringMVC：注解-ControllerAdvice的工作原理"><a href="#SpringMVC：注解-ControllerAdvice的工作原理" class="headerlink" title="SpringMVC：注解@ControllerAdvice的工作原理"></a>SpringMVC：注解@ControllerAdvice的工作原理</h1><p><code>Spring MVC</code>中，通过组合使用注解<code>@ControllerAdvice</code>和其他一些注解，我们可以为开发人员实现的控制器类做一些全局性的定制，具体来讲，可作如下定制 :</p><ul><li><p>结合<code>@ExceptionHandler</code>使用 ==&gt; 添加统一的异常处理控制器方法</p></li><li><p>结合<code>@ModelAttribute</code>使用 ==&gt; 使用共用方法添加渲染视图的数据模型属性</p></li><li><p>结合<code>@InitBinder</code>使用 ==&gt; 使用共用方法初始化控制器方法调用使用的数据绑定器</p><blockquote><p>数据绑定器涉及到哪些参数/属性需要/不需要绑定，设置数据类型转换时使用的<code>PropertyEditor</code>,<code>Formatter</code>等。</p></blockquote></li></ul><p>那么，<code>@ControllerAdvice</code>的工作原理又是怎样的呢 ？这篇文章，我们就一探究竟。</p><h2 id="1-注解-ControllerAdvice是如何被发现的"><a href="#1-注解-ControllerAdvice是如何被发现的" class="headerlink" title="1. 注解@ControllerAdvice是如何被发现的 ?"></a>1. 注解<code>@ControllerAdvice</code>是如何被发现的 ?</h2><p>首先,容器启动时，会定义类型为<code>RequestMappingHandlerAdapter</code>的<code>bean</code>组件，这是<code>DispatcherServlet</code>用于执行控制器方法的<code>HandlerAdapter</code>,它实现了接口<code>InitializingBean</code>,所以自身在初始化时其方法<code>#afterPropertiesSet</code>会被调用执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line"> initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 省略掉无关代码 </span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可以看出，<code>RequestMappingHandlerAdapter bean</code>组件在自身初始化时调用了<code>#initControllerAdviceCache</code>,从这个方法的名字上就可以看出，这是一个<code>ControllerAdvice</code>相关的初始化函数，而<code>#initControllerAdviceCache</code>具体又做了什么呢？我们继续来看 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initControllerAdviceCache</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (getApplicationContext() == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 找到所有使用了注解 @ControllerAdvice 的bean组件 </span></span><br><span class="line"> List&lt;ControllerAdviceBean&gt; adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line"> AnnotationAwareOrderComparator.sort(adviceBeans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// this. requestResponseBodyAdvice : </span></span><br><span class="line">   <span class="comment">//   用于记录所有 @ControllerAdvice + RequestBodyAdvice/ResponseBodyAdvice bean </span></span><br><span class="line">   <span class="comment">// this.modelAttributeAdviceCache : </span></span><br><span class="line">   <span class="comment">//   用于记录所有 @ControllerAdvice bean组件中的 @ModuleAttribute 方法</span></span><br><span class="line">   <span class="comment">// this.initBinderAdviceCache : </span></span><br><span class="line">   <span class="comment">//  用于记录所有 @ControllerAdvice bean组件中的 @InitBinder 方法</span></span><br><span class="line">   <span class="comment">// 用于临时记录所有 @ControllerAdvice + RequestResponseBodyAdvice bean</span></span><br><span class="line"> List&lt;Object&gt; requestResponseBodyAdviceBeans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历每个使用了注解 @ControllerAdvice 的 bean 组件</span></span><br><span class="line"> <span class="keyword">for</span> (ControllerAdviceBean adviceBean : adviceBeans) &#123;</span><br><span class="line">  Class&lt;?&gt; beanType = adviceBean.getBeanType();</span><br><span class="line">  <span class="keyword">if</span> (beanType == <span class="literal">null</span>) &#123;</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Unresolvable type for ControllerAdviceBean: &quot;</span> + adviceBean);</span><br><span class="line">  &#125;</span><br><span class="line">       <span class="comment">// 获取当前  ControllerAdviceBean 中所有使用了 @ModelAttribute 注解的方法</span></span><br><span class="line">  Set&lt;Method&gt; attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">  <span class="keyword">if</span> (!attrMethods.isEmpty()) &#123;</span><br><span class="line">   <span class="built_in">this</span>.modelAttributeAdviceCache.put(adviceBean, attrMethods);</span><br><span class="line">  &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 获取当前 ControllerAdviceBean 中所有使用了 @InitMethod 注解的方法</span></span><br><span class="line">  Set&lt;Method&gt; binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);</span><br><span class="line">  <span class="keyword">if</span> (!binderMethods.isEmpty()) &#123;</span><br><span class="line">   <span class="built_in">this</span>.initBinderAdviceCache.put(adviceBean, binderMethods);</span><br><span class="line">  &#125;</span><br><span class="line">       <span class="comment">// 如果当前 ControllerAdviceBean 继承自 RequestBodyAdvice，将其登记到 requestResponseBodyAdviceBeans</span></span><br><span class="line">  <span class="keyword">if</span> (RequestBodyAdvice.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">   requestResponseBodyAdviceBeans.add(adviceBean);</span><br><span class="line">  &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 如果当前 ControllerAdviceBean 继承自 ResponseBodyAdvice，将其登记到 requestResponseBodyAdviceBeans  </span></span><br><span class="line">  <span class="keyword">if</span> (ResponseBodyAdvice.class.isAssignableFrom(beanType)) &#123;</span><br><span class="line">   requestResponseBodyAdviceBeans.add(adviceBean);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span> (!requestResponseBodyAdviceBeans.isEmpty()) &#123;</span><br><span class="line">  <span class="built_in">this</span>.requestResponseBodyAdvice.addAll(<span class="number">0</span>, requestResponseBodyAdviceBeans);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">modelSize</span> <span class="operator">=</span> <span class="built_in">this</span>.modelAttributeAdviceCache.size();</span><br><span class="line">  <span class="type">int</span> <span class="variable">binderSize</span> <span class="operator">=</span> <span class="built_in">this</span>.initBinderAdviceCache.size();</span><br><span class="line">  <span class="type">int</span> <span class="variable">reqCount</span> <span class="operator">=</span> getBodyAdviceCount(RequestBodyAdvice.class);</span><br><span class="line">  <span class="type">int</span> <span class="variable">resCount</span> <span class="operator">=</span> getBodyAdviceCount(ResponseBodyAdvice.class);</span><br><span class="line">  <span class="keyword">if</span> (modelSize == <span class="number">0</span> &amp;&amp; binderSize == <span class="number">0</span> &amp;&amp; reqCount == <span class="number">0</span> &amp;&amp; resCount == <span class="number">0</span>) &#123;</span><br><span class="line">   logger.debug(<span class="string">&quot;ControllerAdvice beans: none&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">   logger.debug(<span class="string">&quot;ControllerAdvice beans: &quot;</span> + modelSize + <span class="string">&quot; @ModelAttribute, &quot;</span> + binderSize +</span><br><span class="line">     <span class="string">&quot; @InitBinder, &quot;</span> + reqCount + <span class="string">&quot; RequestBodyAdvice, &quot;</span> + resCount + <span class="string">&quot; ResponseBodyAdvice&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上<code>#initControllerAdviceCache</code>方法的实现逻辑来看，它将容器中所有使用了注解<code>@ControllerAdvice</code>的<code>bean</code>或者其方法都分门别类做了统计，记录到了<code>RequestMappingHandlerAdapter</code>实例的三个属性中 :</p><ul><li><code>requestResponseBodyAdvice</code></li><li>用于记录所有<code>@ControllerAdvice</code> + <code>RequestBodyAdvice</code>/<code>ResponseBodyAdvice</code> <code>bean</code>组件</li><li><code>modelAttributeAdviceCache</code></li><li>用于记录所有 <code>@ControllerAdvice</code> <code>bean</code>组件中的 <code>@ModuleAttribute</code> 方法</li><li><code>initBinderAdviceCache</code></li><li>用于记录所有<code>@ControllerAdvice</code> <code>bean</code>组件中的 <code>@InitBinder</code> 方法</li></ul><p>到此为止，我们知道，使用注解<code>@ControllerAdvice</code>的<code>bean</code>中的信息被提取出来了，但是，这些信息又是怎么使用的呢 ？我们继续来看。</p><h2 id="2-ControllerAdvice-定义信息的使用"><a href="#2-ControllerAdvice-定义信息的使用" class="headerlink" title="2. @ControllerAdvice 定义信息的使用"></a>2. <code>@ControllerAdvice</code> 定义信息的使用</h2><h3 id="1-requestResponseBodyAdvice的使用"><a href="#1-requestResponseBodyAdvice的使用" class="headerlink" title="1. requestResponseBodyAdvice的使用"></a>1. <code>requestResponseBodyAdvice</code>的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the list of argument resolvers to use including built-in resolvers</span></span><br><span class="line"><span class="comment"> * and custom resolvers provided via &#123;<span class="doctag">@link</span> #setCustomArgumentResolvers&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="title function_">getDefaultArgumentResolvers</span><span class="params">()</span> &#123;</span><br><span class="line"> List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ... 省略无关代码        </span></span><br><span class="line"> resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestResponseBodyMethodProcessor</span>(getMessageConverters(), </span><br><span class="line">  <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line"> resolvers.add(<span class="keyword">new</span> <span class="title class_">RequestPartMethodArgumentResolver</span>(getMessageConverters(), </span><br><span class="line">  <span class="built_in">this</span>.requestResponseBodyAdvice));  </span><br><span class="line">    <span class="comment">// ... 省略无关代码</span></span><br><span class="line"> resolvers.add(<span class="keyword">new</span> <span class="title class_">HttpEntityMethodProcessor</span>(getMessageConverters(), </span><br><span class="line">  <span class="built_in">this</span>.requestResponseBodyAdvice));</span><br><span class="line"> <span class="comment">// ... 省略无关代码</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> resolvers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>#getDefaultArgumentResolvers</code>方法用于准备<code>RequestMappingHandlerAdapter</code>执行控制器方法过程中缺省使用的<code>HandlerMethodArgumentResolver</code>,从上面代码可见，<code>requestResponseBodyAdvice</code>会被传递给<code>RequestResponseBodyMethodProcessor</code>/<code>RequestPartMethodArgumentResolver</code>/<code>HttpEntityMethodProcessor</code>这三个参数解析器，不难猜测，它们在工作时会使用到该<code>requestResponseBodyAdvice</code>，但具体怎么使用，为避免过深细节影响理解，本文我们不继续展开。</p><p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4Njc5NjM1NQ==&mid=2247499740&idx=2&sn=5390cf9ce460e3fa6508b58aedeafdab&chksm=ebd5c0f0dca249e62fe73e40fedeb0142542291de704324c5600b79b69aaa5ead4b8d73d71ad&scene=21#wechat_redirect">推荐：超级全面的 SpringBoot 注解介绍</a></p><p>方法<code>#getDefaultArgumentResolvers</code>也在<code>RequestMappingHandlerAdapter</code>初始化方法中被调用执行,如下所示 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="comment">// Do this first, it may add ResponseBody advice beans</span></span><br><span class="line"> initControllerAdviceCache();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers == <span class="literal">null</span>) &#123;</span><br><span class="line">  List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers(); <span class="comment">// &lt;==</span></span><br><span class="line">  <span class="built_in">this</span>.argumentResolvers = <span class="keyword">new</span> <span class="title class_">HandlerMethodArgumentResolverComposite</span>()</span><br><span class="line">          .addResolvers(resolvers);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-modelAttributeAdviceCache的使用"><a href="#2-modelAttributeAdviceCache的使用" class="headerlink" title="2. modelAttributeAdviceCache的使用"></a>2. <code>modelAttributeAdviceCache</code>的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ModelFactory <span class="title function_">getModelFactory</span><span class="params">(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory)</span> &#123;</span><br><span class="line"> <span class="type">SessionAttributesHandler</span> <span class="variable">sessionAttrHandler</span> <span class="operator">=</span> getSessionAttributesHandler(handlerMethod);</span><br><span class="line"> Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span><br><span class="line"> Set&lt;Method&gt; methods = <span class="built_in">this</span>.modelAttributeCache.get(handlerType);</span><br><span class="line"> <span class="keyword">if</span> (methods == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取当前控制器类中使用了 @ModelAttribute 的方法</span></span><br><span class="line">  methods = MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);</span><br><span class="line">  <span class="built_in">this</span>.modelAttributeCache.put(handlerType, methods);</span><br><span class="line"> &#125;</span><br><span class="line"> List&lt;InvocableHandlerMethod&gt; attrMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">// Global methods first</span></span><br><span class="line"> <span class="comment">// 遍历@ControllerAdvice bean中所有使用了 @ModelAttribute 的方法，</span></span><br><span class="line"> <span class="comment">// 将其包装成 InvocableHandlerMethod 放到 attrMethods</span></span><br><span class="line"> <span class="comment">// ********* 这里就是 modelAttributeAdviceCache 被使用到的地方了 ************</span></span><br><span class="line"> <span class="built_in">this</span>.modelAttributeAdviceCache.forEach((clazz, methodSet) -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (clazz.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> clazz.resolveBean();</span><br><span class="line">   <span class="keyword">for</span> (Method method : methodSet) &#123;</span><br><span class="line">    attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 遍历当前控制器类中中所有使用了 @ModelAttribute 的方法，</span></span><br><span class="line"> <span class="comment">// 也将其包装成 InvocableHandlerMethod 放到 attrMethods        </span></span><br><span class="line"> <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> handlerMethod.getBean();</span><br><span class="line">  attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 此时  attrMethods 包含了两类 InvocableHandlerMethod， 分别来自于 :</span></span><br><span class="line"> <span class="comment">// 1. @ControllerAdvice bean 中所有使用了 @ModelAttribute 的方法</span></span><br><span class="line"> <span class="comment">// 2. 当前控制器类中中所有使用了 @ModelAttribute 的方法</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelFactory</span>(attrMethods, binderFactory, sessionAttrHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/ 从指定 bean 的方法 method ，其实是一个使用了注解 <span class="meta">@ModelAttribute</span> 的方法，</span><br><span class="line">/ 构造一个 InvocableHandlerMethod 对象</span><br><span class="line"><span class="keyword">private</span> InvocableHandlerMethod <span class="title function_">createModelAttributeMethod</span><span class="params">(WebDataBinderFactory factory, </span></span><br><span class="line"><span class="params">  Object bean, Method method)</span> &#123;</span><br><span class="line"> <span class="type">InvocableHandlerMethod</span> <span class="variable">attrMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocableHandlerMethod</span>(bean, method);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">  attrMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line"> &#125;</span><br><span class="line"> attrMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line"> attrMethod.setDataBinderFactory(factory);</span><br><span class="line"> <span class="keyword">return</span> attrMethod;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>从此方法可以看到，<code>#getModelFactory</code>方法使用到了<code>modelAttributeAdviceCache</code>，它会根据其中每个元素构造成一个<code>InvocableHandlerMethod</code>,最终传递给要创建的<code>ModelFactory</code>对象。而<code>#getModelFactory</code>又在什么时候被使用呢 ? 它会在<code>RequestMappingHandlerAdapter</code>执行一个控制器方法的准备过程中被调用，如下所示 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">  HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构造调用 handlerMethod 所要使用的数据绑定器工厂  </span></span><br><span class="line">  <span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">        <span class="comment">// 构造调用 handlerMethod 所要使用的数据模型工厂  </span></span><br><span class="line">  <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">      <span class="comment">// 省略无关代码 ...            </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-initBinderAdviceCache的使用"><a href="#3-initBinderAdviceCache的使用" class="headerlink" title="3. initBinderAdviceCache的使用"></a>3. <code>initBinderAdviceCache</code>的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> WebDataBinderFactory <span class="title function_">getDataBinderFactory</span><span class="params">(HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> Class&lt;?&gt; handlerType = handlerMethod.getBeanType();</span><br><span class="line"> Set&lt;Method&gt; methods = <span class="built_in">this</span>.initBinderCache.get(handlerType);</span><br><span class="line"> <span class="keyword">if</span> (methods == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取当前控制器类中使用了 @InitBinder 的方法  </span></span><br><span class="line">  methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS);</span><br><span class="line">  <span class="built_in">this</span>.initBinderCache.put(handlerType, methods);</span><br><span class="line"> &#125;</span><br><span class="line"> List&lt;InvocableHandlerMethod&gt; initBinderMethods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> <span class="comment">// Global methods first</span></span><br><span class="line"> <span class="comment">// 遍历@ControllerAdvice bean中所有使用了 @InitBinder 的方法，</span></span><br><span class="line"> <span class="comment">// 将其包装成 InvocableHandlerMethod 放到 initBinderMethods</span></span><br><span class="line"> <span class="comment">// ********* 这里就是 initBinderAdviceCache 被使用到的地方了 ************        </span></span><br><span class="line"> <span class="built_in">this</span>.initBinderAdviceCache.forEach((clazz, methodSet) -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (clazz.isApplicableToBeanType(handlerType)) &#123;</span><br><span class="line">   <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> clazz.resolveBean();</span><br><span class="line">   <span class="keyword">for</span> (Method method : methodSet) &#123;</span><br><span class="line">    initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 遍历当前控制器类中所有使用了 @InitBinder 的方法，</span></span><br><span class="line"> <span class="comment">// 将其包装成 InvocableHandlerMethod 放到 initBinderMethods        </span></span><br><span class="line"> <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> handlerMethod.getBean();</span><br><span class="line">  initBinderMethods.add(createInitBinderMethod(bean, method));</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="comment">// 此时  initBinderMethods 包含了两类 InvocableHandlerMethod， 分别来自于 :</span></span><br><span class="line"> <span class="comment">// 1. @ControllerAdvice bean 中所有使用了 @InitBinder 的方法</span></span><br><span class="line"> <span class="comment">// 2. 当前控制器类中中所有使用了 @InitBinder 的方法        </span></span><br><span class="line"> <span class="keyword">return</span> createDataBinderFactory(initBinderMethods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/ 从指定 bean 的方法 method ，其实是一个使用了注解 <span class="meta">@InitBinder</span> 的方法，</span><br><span class="line">/ 构造一个 InvocableHandlerMethod 对象</span><br><span class="line"><span class="keyword">private</span> InvocableHandlerMethod <span class="title function_">createInitBinderMethod</span><span class="params">(Object bean, Method method)</span> &#123;</span><br><span class="line"> <span class="type">InvocableHandlerMethod</span> <span class="variable">binderMethod</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvocableHandlerMethod</span>(bean, method);</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">this</span>.initBinderArgumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">  binderMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.initBinderArgumentResolvers);</span><br><span class="line"> &#125;</span><br><span class="line"> binderMethod.setDataBinderFactory(<span class="keyword">new</span> <span class="title class_">DefaultDataBinderFactory</span>(<span class="built_in">this</span>.webBindingInitializer));</span><br><span class="line"> binderMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line"> <span class="keyword">return</span> binderMethod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Template method to create a new InitBinderDataBinderFactory instance.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The default implementation creates a ServletRequestDataBinderFactory.</span></span><br><span class="line"><span class="comment"> * This can be overridden for custom ServletRequestDataBinder subclasses.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> binderMethods &#123;<span class="doctag">@code</span> <span class="doctag">@InitBinder</span>&#125; methods</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the InitBinderDataBinderFactory instance to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception in case of invalid state or arguments</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> InitBinderDataBinderFactory <span class="title function_">createDataBinderFactory</span><span class="params">(</span></span><br><span class="line"><span class="params">          List&lt;InvocableHandlerMethod&gt; binderMethods)</span></span><br><span class="line">  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletRequestDataBinderFactory</span>(binderMethods, getWebBindingInitializer());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从此方法可以看到，<code>#getDataBinderFactory</code>方法使用到了<code>initBinderAdviceCache</code>，它会根据其中每个元素构造成一个<code>InvocableHandlerMethod</code>,最终传递给要创建的<code>InitBinderDataBinderFactory</code>对象。而<code>#getDataBinderFactory</code>又在什么时候被使用呢 ? 它会在<code>RequestMappingHandlerAdapter</code>执行一个控制器方法的准备过程中被调用，如下所示 :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,</span></span><br><span class="line"><span class="params">  HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line"> <span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 构造调用 handlerMethod 所要使用的数据绑定器工厂  </span></span><br><span class="line">  <span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">        <span class="comment">// 构造调用 handlerMethod 所要使用的数据模型工厂  </span></span><br><span class="line">  <span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line">      <span class="comment">// 省略无关代码 ...            </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们基本上可以看到，通过<code>@ControllerAdvice</code>注解的<code>bean</code>组件所定义的<code>@ModelAttribute</code>/<code>@InitBinder</code>方法，或者<code>RequestBodyAdvice</code>/<code>ResponseBodyAdvice</code>，是如何被<code>RequestMappingHandlerAdapter</code>提取和使用的了。虽然我们并未深入到更细微的组件研究它们最终的使用，不过结合这些组件命名以及这些更深一层的使用者组件的名称，即便是猜测，相信你也不难理解猜到它们如何被使用了。</p><p>不知道你注意到没有，关于<code>@ControllerAdvice</code>和<code>@ExceptionHandler</code>这一组合，在上面提到的<code>RequestMappingHandlerAdapter</code>逻辑中，并未涉及到。那如果使用了这种组合，又会是怎样一种工作机制呢 ？事实上，<code>@ControllerAdvice</code>和<code>@ExceptionHandler</code>这一组合所做的定义，会被<code>ExceptionHandlerExceptionResolver</code>消费使用。不过关于<code>ExceptionHandlerExceptionResolver</code>我们会另外行文介绍，通过这篇文章中的例子，理解<code>@ControllerAdvide</code>的工作原理已经不是问题了。</p><h1 id="如何优雅处理重复请求-并发请求？"><a href="#如何优雅处理重复请求-并发请求？" class="headerlink" title="如何优雅处理重复请求/并发请求？"></a>如何优雅处理重复请求/并发请求？</h1><p>对于一些用户请求，在某些情况下是可能重复发送的，如果是查询类操作并无大碍，但其中有些是涉及写入操作的，一旦重复了，可能会导致很严重的后果，例如交易的接口如果重复请求可能会重复下单。</p><p>重复的场景有可能是：</p><ol><li>黑客拦截了请求，重放</li><li>前端/客户端因为某些原因请求重复发送了，或者用户在很短的时间内重复点击了。</li><li>网关重发</li><li>….</li></ol><p>本文讨论的是如何在服务端优雅地统一处理这种情况，如何禁止用户重复点击等客户端操作不在本文的讨论范畴。</p><h2 id="利用唯一请求编号去重"><a href="#利用唯一请求编号去重" class="headerlink" title="利用唯一请求编号去重"></a>利用唯一请求编号去重</h2><p>你可能会想到的是，只要请求有唯一的请求编号，那么就能借用Redis做这个去重——只要这个唯一请求编号在redis存在，证明处理过，那么就认为是重复的</p><p>代码大概如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;REQ12343456788&quot;</span>;<span class="comment">//请求唯一编号</span></span><br><span class="line"><span class="type">long</span> <span class="variable">expireTime</span> <span class="operator">=</span>  <span class="number">1000</span>;<span class="comment">// 1000毫秒过期，1000ms内的重复请求会认为重复</span></span><br><span class="line"><span class="type">long</span> <span class="variable">expireAt</span> <span class="operator">=</span> System.currentTimeMillis() + expireTime;</span><br><span class="line"><span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> <span class="string">&quot;expireAt@&quot;</span> + expireAt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//redis key还存在的话要就认为请求是重复的</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">firstSet</span> <span class="operator">=</span> stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.set(KEY.getBytes(), val.getBytes(), Expiration.milliseconds(expireTime), RedisStringCommands.SetOption.SET_IF_ABSENT));</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> isConsiderDup;</span><br><span class="line"><span class="keyword">if</span> (firstSet != <span class="literal">null</span> &amp;&amp; firstSet) &#123;<span class="comment">// 第一次访问</span></span><br><span class="line">    isConsiderDup = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">// redis值已存在，认为是重复了</span></span><br><span class="line">    isConsiderDup = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="业务参数去重"><a href="#业务参数去重" class="headerlink" title="业务参数去重"></a>业务参数去重</h2><p>上面的方案能解决具备唯一请求编号的场景，例如每次写请求之前都是服务端返回一个唯一编号给客户端，客户端带着这个请求号做请求，服务端即可完成去重拦截。</p><p>但是，很多的场景下，请求并不会带这样的唯一编号！那么我们能否针对请求的参数作为一个请求的标识呢？</p><p>先考虑简单的场景，假设请求参数只有一个字段reqParam，我们可以利用以下标识去判断这个请求是否重复。<strong>用户ID:接口名:请求参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;dedup:U=&quot;</span>+userId + <span class="string">&quot;M=&quot;</span> + method + <span class="string">&quot;P=&quot;</span> + reqParam;</span><br></pre></td></tr></table></figure><p>那么当同一个用户访问同一个接口，带着同样的reqParam过来，我们就能定位到他是重复的了。</p><p>但是问题是，我们的接口通常不是这么简单，以目前的主流，我们的参数通常是一个JSON。那么针对这种场景，我们怎么去重呢？</p><h3 id="计算请求参数的摘要作为参数标识"><a href="#计算请求参数的摘要作为参数标识" class="headerlink" title="计算请求参数的摘要作为参数标识"></a>计算请求参数的摘要作为参数标识</h3><p>假设我们把请求参数（JSON）按KEY做升序排序，排序后拼成一个字符串，作为KEY值呢？但这可能非常的长，所以我们可以考虑对这个字符串求一个MD5作为参数的摘要，以这个摘要去取代reqParam的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;dedup:U=&quot;</span>+userId + <span class="string">&quot;M=&quot;</span> + method + <span class="string">&quot;P=&quot;</span> + reqParamMD5;</span><br></pre></td></tr></table></figure><p>这样，请求的唯一标识就打上了！</p><p>注：MD5理论上可能会重复，但是去重通常是短时间窗口内的去重（例如一秒），一个短时间内同一个用户同样的接口能拼出不同的参数导致一样的MD5几乎是不可能的。</p><h3 id="继续优化，考虑剔除部分时间因子"><a href="#继续优化，考虑剔除部分时间因子" class="headerlink" title="继续优化，考虑剔除部分时间因子"></a>继续优化，考虑剔除部分时间因子</h3><p>上面的问题其实已经是一个很不错的解决方案了，但是实际投入使用的时候可能发现有些问题：某些请求用户短时间内重复的点击了（例如1000毫秒发送了三次请求），但绕过了上面的去重判断（不同的KEY值）。</p><p>原因是这些请求参数的字段里面，<strong>是带时间字段的</strong>，这个字段标记用户请求的时间，服务端可以借此丢弃掉一些老的请求（例如5秒前）。如下面的例子，请求的其他参数是一样的，除了请求时间相差了一秒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个请求一样，但是请求时间差一秒</span></span><br><span class="line"> <span class="type">String</span> <span class="variable">req</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\&quot;requestTime\&quot; :\&quot;20190101120001\&quot;,\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\&quot;requestValue\&quot; :\&quot;1000\&quot;,\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\&quot;requestKey\&quot; :\&quot;key\&quot;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"> <span class="type">String</span> <span class="variable">req2</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\&quot;requestTime\&quot; :\&quot;20190101120002\&quot;,\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\&quot;requestValue\&quot; :\&quot;1000\&quot;,\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;\&quot;requestKey\&quot; :\&quot;key\&quot;\n&quot;</span> +</span><br><span class="line">         <span class="string">&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><p>这种请求，我们也很可能需要挡住后面的重复请求。所以求业务参数摘要之前，需要剔除这类时间字段。还有类似的字段可能是GPS的经纬度字段（重复请求间可能有极小的差别）。</p><h2 id="请求去重工具类，Java实现"><a href="#请求去重工具类，Java实现" class="headerlink" title="请求去重工具类，Java实现"></a>请求去重工具类，Java实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReqDedupHelper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reqJSON 请求的参数，这里通常是JSON</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> excludeKeys 请求参数里面要去除哪些字段再求摘要</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 去除参数的MD5摘要</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dedupParamMD5</span><span class="params">(<span class="keyword">final</span> String reqJSON, String... excludeKeys)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">decreptParam</span> <span class="operator">=</span> reqJSON;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeMap</span> <span class="variable">paramTreeMap</span> <span class="operator">=</span> JSON.parseObject(decreptParam, TreeMap.class);</span><br><span class="line">        <span class="keyword">if</span> (excludeKeys!=<span class="literal">null</span>) &#123;</span><br><span class="line">            List&lt;String&gt; dedupExcludeKeys = Arrays.asList(excludeKeys);</span><br><span class="line">            <span class="keyword">if</span> (!dedupExcludeKeys.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dedupExcludeKey : dedupExcludeKeys) &#123;</span><br><span class="line">                    paramTreeMap.remove(dedupExcludeKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">paramTreeMapJSON</span> <span class="operator">=</span> JSON.toJSONString(paramTreeMap);</span><br><span class="line">        <span class="type">String</span> <span class="variable">md5deDupParam</span> <span class="operator">=</span> jdkMD5(paramTreeMapJSON);</span><br><span class="line">        log.debug(<span class="string">&quot;md5deDupParam = &#123;&#125;, excludeKeys = &#123;&#125; &#123;&#125;&quot;</span>, md5deDupParam, Arrays.deepToString(excludeKeys), paramTreeMapJSON);</span><br><span class="line">        <span class="keyword">return</span> md5deDupParam;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">jdkMD5</span><span class="params">(String src)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">messageDigest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">            <span class="type">byte</span>[] mdBytes = messageDigest.digest(src.getBytes());</span><br><span class="line">            res = DatatypeConverter.printHexBinary(mdBytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一些测试日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//两个请求一样，但是请求时间差一秒</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">req</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestTime\&quot; :\&quot;20190101120001\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestValue\&quot; :\&quot;1000\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestKey\&quot; :\&quot;key\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">req2</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestTime\&quot; :\&quot;20190101120002\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestValue\&quot; :\&quot;1000\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;\&quot;requestKey\&quot; :\&quot;key\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全参数比对，所以两个参数MD5不同</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dedupMD5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReqDedupHelper</span>().dedupParamMD5(req);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dedupMD52</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReqDedupHelper</span>().dedupParamMD5(req2);</span><br><span class="line">    System.out.println(<span class="string">&quot;req1MD5 = &quot;</span>+ dedupMD5+<span class="string">&quot; , req2MD5=&quot;</span>+dedupMD52);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去除时间参数比对，MD5相同</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dedupMD53</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReqDedupHelper</span>().dedupParamMD5(req,<span class="string">&quot;requestTime&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">dedupMD54</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReqDedupHelper</span>().dedupParamMD5(req2,<span class="string">&quot;requestTime&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;req1MD5 = &quot;</span>+ dedupMD53+<span class="string">&quot; , req2MD5=&quot;</span>+dedupMD54);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">req1MD5 = 9E054D36439EBDD0604C5E65EB5C8267 , req2MD5=A2D20BAC78551C4CA09BEF97FE468A3F</span><br><span class="line">req1MD5 = C2A36FED15128E9E878583CAAAFEFDE9 , req2MD5=C2A36FED15128E9E878583CAAAFEFDE9</span><br></pre></td></tr></table></figure><p>日志说明：</p><ul><li>一开始两个参数由于requestTime是不同的，所以求去重参数摘要的时候可以发现两个值是不一样的</li><li>第二次调用的时候，去除了requestTime再求摘要（第二个参数中传入了”requestTime”），则发现两个摘要是一样的，符合预期。</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>至此，我们可以得到完整的去重解决方案，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String userId= <span class="string">&quot;12345678&quot;</span>;<span class="comment">//用户</span></span><br><span class="line"><span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> <span class="string">&quot;pay&quot;</span>;<span class="comment">//接口名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">dedupMD5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReqDedupHelper</span>().dedupParamMD5(req,<span class="string">&quot;requestTime&quot;</span>);<span class="comment">//计算请求参数摘要，其中剔除里面请求时间的干扰</span></span><br><span class="line"><span class="type">String</span> <span class="variable">KEY</span> <span class="operator">=</span> <span class="string">&quot;dedup:U=&quot;</span> + userId + <span class="string">&quot;M=&quot;</span> + method + <span class="string">&quot;P=&quot;</span> + dedupMD5;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">expireTime</span> <span class="operator">=</span>  <span class="number">1000</span>;<span class="comment">// 1000毫秒过期，1000ms内的重复请求会认为重复</span></span><br><span class="line"><span class="type">long</span> <span class="variable">expireAt</span> <span class="operator">=</span> System.currentTimeMillis() + expireTime;</span><br><span class="line"><span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> <span class="string">&quot;expireAt@&quot;</span> + expireAt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span>直接SETNX不支持带过期时间，所以设置+过期不是原子操作，极端情况下可能设置了就不过期了，后面相同请求可能会误以为需要去重，所以这里使用底层API，保证SETNX+过期时间是原子操作</span></span><br><span class="line"><span class="type">Boolean</span> <span class="variable">firstSet</span> <span class="operator">=</span> stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; connection.set(KEY.getBytes(), val.getBytes(), Expiration.milliseconds(expireTime),</span><br><span class="line">        RedisStringCommands.SetOption.SET_IF_ABSENT));</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> isConsiderDup;</span><br><span class="line"><span class="keyword">if</span> (firstSet != <span class="literal">null</span> &amp;&amp; firstSet) &#123;</span><br><span class="line">    isConsiderDup = <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    isConsiderDup = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-AOP看这篇就够辣"><a href="#Spring-AOP看这篇就够辣" class="headerlink" title="Spring AOP看这篇就够辣~"></a>Spring AOP看这篇就够辣~</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>其实, 接触了这么久的 AOP, 我感觉, AOP 给人难以理解的一个关键点是它的概念比较多, 而且坑爹的是, 这些概念经过了中文翻译后, 变得面目全非, 相同的一个术语, 在不同的翻译下, 含义总有着各种莫名其妙的差别. 鉴于此, 我在本章的开头, 着重为为大家介绍一个 Spring AOP 的各项术语的基本含义. 为了术语传达的准确性, 我在接下来的叙述中, 能使用英文术语的地方, 尽量使用英文.</p><h2 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h2><p>AOP(Aspect-Oriented Programming), 即 <strong>面向切面编程</strong> , 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角. 在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 <strong>Aspect(切面)</strong></p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="Aspect-切面"><a href="#Aspect-切面" class="headerlink" title="Aspect(切面)"></a>Aspect(切面)</h3><p><code>aspect</code> 由 <code>pointcount</code> 和 <code>advice</code> 组成, 它既包含了横切逻辑的定义, 也包括了连接点的定义. Spring AOP就是负责实施切面的框架, 它将切面所定义的横切逻辑织入到切面所指定的连接点中. AOP的工作重心在于如何将增强织入目标对象的连接点上, 这里包含两个工作:</p><ol><li>如何通过 pointcut 和 advice 定位到特定的 joinpoint 上</li><li>如何在 advice 中编写切面代码.</li></ol><p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面.</strong></p><h3 id="advice-增强"><a href="#advice-增强" class="headerlink" title="advice(增强)"></a>advice(增强)</h3><p>由 aspect 添加到特定的 join point(即满足 point cut 规则的 join point) 的一段代码. 许多 AOP框架, 包括 Spring AOP, 会将 advice 模拟为一个拦截器(interceptor), 并且在 join point 上维护多个 advice, 进行层层拦截. 例如 HTTP 鉴权的实现, 我们可以为每个使用 RequestMapping 标注的方法织入 advice, 当 HTTP 请求到来时, 首先进入到 advice 代码中, 在这里我们可以分析这个 HTTP 请求是否有相应的权限, 如果有, 则执行 Controller, 如果没有, 则抛出异常. 这里的 advice 就扮演着鉴权拦截器的角色了.</p><h3 id="连接点-join-point"><a href="#连接点-join-point" class="headerlink" title="连接点(join point)"></a>连接点(join point)</h3><blockquote><p>a point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution.</p></blockquote><p>程序运行中的一些时间点, 例如一个方法的执行, 或者是一个异常的处理.<code>在 Spring AOP 中, join point 总是方法的执行点, 即只有方法连接点.</code></p><h3 id="切点-point-cut"><a href="#切点-point-cut" class="headerlink" title="切点(point cut)"></a>切点(point cut)</h3><p>匹配 join point 的谓词(a predicate that matches join points). Advice 是和特定的 point cut 关联的, 并且在 point cut 相匹配的 join point 中执行.<code>在 Spring 中, 所有的方法都可以认为是 joinpoint, 但是我们并不希望在所有的方法上都添加 Advice, 而 pointcut 的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice.</code></p><h3 id="关于join-point-和-point-cut-的区别"><a href="#关于join-point-和-point-cut-的区别" class="headerlink" title="关于join point 和 point cut 的区别"></a>关于join point 和 point cut 的区别</h3><p>在 Spring AOP 中, 所有的方法执行都是 join point. 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 因此 join point 和 point cut 本质上就是两个不同纬度上的东西.<code>advice 是在 join point 上执行的, 而 point cut 规定了哪些 join point 可以执行哪些 advice</code></p><h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h3><p>为一个类型添加额外的方法或字段. Spring AOP 允许我们为 <code>目标对象</code> 引入新的接口(和对应的实现). 例如我们可以使用 introduction 来为一个 bean 实现 IsModified 接口, 并以此来简化 caching 的实现.</p><h3 id="目标对象-Target"><a href="#目标对象-Target" class="headerlink" title="目标对象(Target)"></a>目标对象(Target)</h3><p>织入 advice 的目标对象. 目标对象也被称为 <code>advised object</code>.<code>因为 Spring AOP 使用运行时代理的方式来实现 aspect, 因此 adviced object 总是一个代理对象(proxied object)``注意, adviced object 指的不是原来的类, 而是织入 advice 后所产生的代理类.</code></p><h3 id="AOP-proxy"><a href="#AOP-proxy" class="headerlink" title="AOP proxy"></a>AOP proxy</h3><p>一个类被 AOP 织入 advice, 就会产生一个结果类, 它是融合了原类和增强逻辑的代理类. 在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象.</p><h3 id="织入-Weaving"><a href="#织入-Weaving" class="headerlink" title="织入(Weaving)"></a>织入(Weaving)</h3><p>将 aspect 和其他对象连接起来, 并创建 adviced object 的过程. 根据不同的实现技术, AOP织入有三种方式:</p><ul><li>编译器织入, 这要求有特殊的Java编译器.</li><li>类装载期织入, 这需要有特殊的类装载器.</li><li>动态代理织入, 在运行期为目标类添加增强(Advice)生成子类的方式. Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期织入.</li></ul><h2 id="advice-的类型"><a href="#advice-的类型" class="headerlink" title="advice 的类型"></a>advice 的类型</h2><ul><li>before advice, 在 join point 前被执行的 advice. 虽然 before advice 是在 join point 前被执行, 但是它并不能够阻止 join point 的执行, 除非发生了异常(即我们在 before advice 代码中, 不能人为地决定是否继续执行 join point 中的代码)</li><li>after return advice, 在一个 join point 正常返回后执行的 advice</li><li>after throwing advice, 当一个 join point 抛出异常后执行的 advice</li><li>after(final) advice, 无论一个 join point 是正常退出还是发生了异常, 都会被执行的 advice.</li><li>around advice, 在 join point 前和 joint point 退出后都执行的 advice. 这个是最常用的 advice.</li></ul><h2 id="关于-AOP-Proxy"><a href="#关于-AOP-Proxy" class="headerlink" title="关于 AOP Proxy"></a>关于 AOP Proxy</h2><p>Spring AOP 默认使用标准的 JDK 动态代理(dynamic proxy)技术来实现 AOP 代理, 通过它, 我们可以为任意的接口实现代理.<code>如果需要为一个类实现代理, 那么可以使用 CGLIB 代理.</code> 当一个业务逻辑对象没有实现接口时, 那么Spring AOP 就默认使用 CGLIB 来作为 AOP 代理了. 即如果我们需要为一个方法织入 advice, 但是这个方法不是一个接口所提供的方法, 则此时 Spring AOP 会使用 CGLIB 来实现动态代理. 鉴于此, Spring AOP 建议基于接口编程, 对接口进行 AOP 而不是类.</p><h2 id="彻底理解-aspect-join-point-point-cut-advice"><a href="#彻底理解-aspect-join-point-point-cut-advice" class="headerlink" title="彻底理解 aspect, join point, point cut, advice"></a>彻底理解 aspect, join point, point cut, advice</h2><p>看完了上面的理论部分知识, 我相信还是会有不少朋友感觉到 AOP 的概念还是很模糊, 对 AOP 中的各种概念理解的还不是很透彻. 其实这很正常, 因为 AOP 中的概念是在是太多了, 我当时也是花了老大劲才梳理清楚的. 下面我以一个简单的例子来比喻一下 AOP 中 aspect, jointpoint, pointcut 与 advice 之间的关系.</p><p>让我们来假设一下, 从前有一个叫爪哇的小县城, 在一个月黑风高的晚上, 这个县城中发生了命案. 作案的凶手十分狡猾, 现场没有留下什么有价值的线索. 不过万幸的是, 刚从隔壁回来的老王恰好在这时候无意中发现了凶手行凶的过程, 但是由于天色已晚, 加上凶手蒙着面, 老王并没有看清凶手的面目, 只知道凶手是个男性, 身高约七尺五寸. 爪哇县的县令根据老王的描述, 对守门的士兵下命令说: 凡是发现有身高七尺五寸的男性, 都要抓过来审问. 士兵当然不敢违背县令的命令, 只好把进出城的所有符合条件的人都抓了起来.</p><p>来让我们看一下上面的一个小故事和 AOP 到底有什么对应关系. 首先我们知道, 在 Spring AOP 中 join point 指代的是所有方法的执行点, 而 point cut 是一个描述信息, 它修饰的是 join point, 通过 point cut, 我们就可以确定哪些 join point 可以被织入 Advice. 对应到我们在上面举的例子, 我们可以做一个简单的类比, join point 就相当于 <strong>爪哇的小县城里的百姓</strong> , point cut 就相当于 <strong>老王所做的指控, 即凶手是个男性, 身高约七尺五寸</strong> , 而 advice 则是施加在符合老王所描述的嫌疑人的动作: <strong>抓过来审问</strong> . 为什么可以这样类比呢?</p><ul><li>join point –&gt; 爪哇的小县城里的百姓: 因为根据定义, join point 是所有可能被织入 advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 join point. 而在我们上面的例子中, 命案发生在小县城中, 按理说在此县城中的所有人都有可能是嫌疑人.</li><li>point cut –&gt; 男性, 身高约七尺五寸: 我们知道, 所有的方法(joint point) 都可以织入 advice, 但是我们并不希望在所有方法上都织入 advice, 而 pointcut 的作用就是提供一组规则来匹配joinpoint, 给满足规则的 joinpoint 添加 advice. 同理, 对于县令来说, 他再昏庸, 也知道不能把县城中的所有百姓都抓起来审问, 而是根据<code>凶手是个男性, 身高约七尺五寸</code>, 把符合条件的人抓起来. 在这里 <code>凶手是个男性, 身高约七尺五寸</code> 就是一个修饰谓语, 它限定了凶手的范围, 满足此修饰规则的百姓都是嫌疑人, 都需要抓起来审问.</li><li>advice –&gt; 抓过来审问, advice 是一个动作, 即一段 Java 代码, 这段 Java 代码是作用于 point cut 所限定的那些 join point 上的. 同理, 对比到我们的例子中, <code>抓过来审问</code> 这个动作就是对作用于那些满足 <code>男性, 身高约七尺五寸</code> 的<code>爪哇的小县城里的百姓</code>.</li><li>aspect: aspect 是 point cut 与 advice 的组合, 因此在这里我们就可以类比: <strong>“根据老王的线索, 凡是发现有身高七尺五寸的男性, 都要抓过来审问”</strong> 这一整个动作可以被认为是一个 aspect.</li></ul><hr><p>或则我们也可以从语法的角度来简单类比一下. 我们在学英语时, 经常会接触什么 <code>定语</code>, <code>被动句</code> 之类的概念, 那么可以做一个不严谨的类比, 即 <code>joinpoint</code> 可以认为是一个 <code>宾语</code>, 而 <code>pointcut</code> 则可以类比为修饰 <code>joinpoint</code> 的定语, 那么整个 <code>aspect</code> 就可以描述为: <code>满足 pointcut 规则的 joinpoint 会被添加相应的 advice 操作.</code></p><h2 id="AspectJ-支持"><a href="#AspectJ-支持" class="headerlink" title="@AspectJ 支持"></a>@AspectJ 支持</h2><p><strong>@AspectJ</strong> 是一种使用 Java 注解来实现 AOP 的编码风格. @AspectJ 风格的 AOP 是 AspectJ Project 在 AspectJ 5 中引入的, 并且 Spring 也支持@AspectJ 的 AOP 风格.</p><h2 id="使能-AspectJ-支持"><a href="#使能-AspectJ-支持" class="headerlink" title="使能 @AspectJ 支持"></a>使能 @AspectJ 支持</h2><p>@AspectJ 可以以 XML 的方式或以注解的方式来使能, 并且不论以哪种方式使能@ASpectJ, 我们都必须保证 aspectjweaver.jar 在 classpath 中.</p><h3 id="使用-Java-Configuration-方式使能-AspectJ"><a href="#使用-Java-Configuration-方式使能-AspectJ" class="headerlink" title="使用 Java Configuration 方式使能@AspectJ"></a>使用 Java Configuration 方式使能@AspectJ</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-XML-方式使能-AspectJ"><a href="#使用-XML-方式使能-AspectJ" class="headerlink" title="使用 XML 方式使能@AspectJ"></a>使用 XML 方式使能@AspectJ</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="定义-aspect-切面"><a href="#定义-aspect-切面" class="headerlink" title="定义 aspect(切面)"></a>定义 aspect(切面)</h2><p>当使用注解 <strong>@Aspect</strong> 标注一个 Bean 后, 那么 Spring 框架会自动收集这些 Bean, 并添加到 Spring AOP 中, 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">注意, 仅仅使用<span class="meta">@Aspect</span> 注解, 并不能将一个 Java 对象转换为 Bean, 因此我们还需要使用类似 <span class="meta">@Component</span> 之类的注解.`</span><br><span class="line">`注意, 如果一个 类被<span class="meta">@Aspect</span> 标注, 则这个类就不能是其他 aspect 的 **advised object** 了, 因为使用 <span class="meta">@Aspect</span> 后, 这个类就会被排除在 auto-proxying 机制之外.</span><br></pre></td></tr></table></figure><h2 id="声明-pointcut"><a href="#声明-pointcut" class="headerlink" title="声明 pointcut"></a>声明 pointcut</h2><p>一个 pointcut 的声明由两部分组成:</p><ul><li>一个方法签名, 包括方法名和相关参数</li><li>一个 pointcut 表达式, 用来指定哪些方法执行是我们感兴趣的(即因此可以织入 advice).</li></ul><p>在@AspectJ 风格的 AOP 中, 我们使用一个方法来描述 pointcut, 即:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.xys.service.UserService.*(..))&quot;)</span> <span class="comment">// 切点表达式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dataAccessOperation</span><span class="params">()</span> &#123;&#125; <span class="comment">// 切点前面</span></span><br></pre></td></tr></table></figure><p><code>这个方法必须无返回值.``这个方法本身就是 pointcut signature, pointcut 表达式使用@Pointcut 注解指定.</code>上面我们简单地定义了一个 pointcut, 这个 pointcut 所描述的是: 匹配所有在包 <strong>com.xys.service.UserService</strong> 下的所有方法的执行.</p><h3 id="切点标志符-designator"><a href="#切点标志符-designator" class="headerlink" title="切点标志符(designator)"></a>切点标志符(designator)</h3><p>AspectJ5 的切点表达式由标志符(designator)和操作参数组成. 如 “execution( <em>greetTo(..))” 的切点表达式, <strong>execution</strong> 就是 标志符, 而圆括号里的</em> greetTo(..) 就是操作参数</p><h4 id="execution"><a href="#execution" class="headerlink" title="execution"></a>execution</h4><p>匹配 join point 的执行, 例如 “execution(* hello(..))” 表示匹配所有目标类中的 hello() 方法. 这个是最基本的 pointcut 标志符.</p><h4 id="within"><a href="#within" class="headerlink" title="within"></a>within</h4><p>匹配特定包下的所有 join point, 例如 <code>within(com.xys.*)</code> 表示 com.xys 包中的所有连接点, 即包中的所有类的所有方法. 而 <code>within(com.xys.service.*Service)</code> 表示在 com.xys.service 包中所有以 Service 结尾的类的所有的连接点.</p><h4 id="this-与-target"><a href="#this-与-target" class="headerlink" title="this 与 target"></a>this 与 target</h4><p>this 的作用是匹配一个 bean, 这个 bean(Spring AOP proxy) 是一个给定类型的实例(instance of). 而 target 匹配的是一个目标对象(target object, 即需要织入 advice 的原始的类), 此对象是一个给定类型的实例(instance of).</p><h4 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h4><p>匹配 bean 名字为指定值的 bean 下的所有方法, 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bean(*Service) <span class="comment">// 匹配名字后缀为 Service 的 bean 下的所有方法</span></span><br><span class="line">bean(myService) <span class="comment">// 匹配名字为 myService 的 bean 下的所有方法</span></span><br></pre></td></tr></table></figure><h4 id="args"><a href="#args" class="headerlink" title="args"></a>args</h4><p>匹配参数满足要求的的方法. 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;within(com.xys.demo2.*)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut2</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(value = &quot;pointcut2()  &amp;&amp;  args(name)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;---page: &#123;&#125;---&quot;</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NormalService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;---NormalService: someMethod invoked---&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;---NormalService: test invoked---&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;服务一切正常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 NormalService.test 执行时, 则 advice <code>doSomething</code> 就会执行, test 方法的参数 name 就会传递到 <code>doSomething</code> 中.</p><p>常用例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配只有一个参数 name 的方法</span></span><br><span class="line"><span class="meta">@Before(value = &quot;aspectMethod()  &amp;&amp;  args(name)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String name)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配第一个参数为 name 的方法</span></span><br><span class="line"><span class="meta">@Before(value = &quot;aspectMethod()  &amp;&amp;  args(name, ..)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String name)</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配第二个参数为 name 的方法</span></span><br><span class="line">Before(value = <span class="string">&quot;aspectMethod()  &amp;&amp;  args(*, name, ..)&quot;</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(String name)</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="annotation"><a href="#annotation" class="headerlink" title="@annotation"></a>@annotation</h4><p>匹配由指定注解所标注的方法, 例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;@annotation(com.xys.demo1.AuthChecker)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointcut</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则匹配由注解 <code>AuthChecker</code> 所标注的方法.</p><h3 id="常见的切点表达式"><a href="#常见的切点表达式" class="headerlink" title="常见的切点表达式"></a>常见的切点表达式</h3><h4 id="匹配方法签名"><a href="#匹配方法签名" class="headerlink" title="匹配方法签名"></a>匹配方法签名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配指定包中的所有的方法</span></span><br><span class="line">execution(* com.xys.service.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配当前包中的指定类的所有方法</span></span><br><span class="line">execution(* UserService.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配指定包中的所有 public 方法</span></span><br><span class="line">execution(<span class="keyword">public</span> * com.xys.service.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配指定包中的所有 public 方法, 并且返回值是 int 类型的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="type">int</span> com.xys.service.*(..))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配指定包中的所有 public 方法, 并且第一个参数是 String, 返回值是 int 类型的方法</span></span><br><span class="line">execution(<span class="keyword">public</span> <span class="type">int</span> com.xys.service.*(String name, ..))</span><br></pre></td></tr></table></figure><h4 id="匹配类型签名"><a href="#匹配类型签名" class="headerlink" title="匹配类型签名"></a>匹配类型签名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配指定包中的所有的方法, 但不包括子包</span></span><br><span class="line">within(com.xys.service.*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配指定包中的所有的方法, 包括子包</span></span><br><span class="line">within(com.xys.service..*)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配当前包中的指定类中的方法</span></span><br><span class="line">within(UserService)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配一个接口的所有实现类中的实现的方法</span></span><br><span class="line">within(UserDao+)</span><br></pre></td></tr></table></figure><h4 id="匹配-Bean-名字"><a href="#匹配-Bean-名字" class="headerlink" title="匹配 Bean 名字"></a>匹配 Bean 名字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配以指定名字结尾的 Bean 中的所有方法</span></span><br><span class="line">bean(*Service)</span><br></pre></td></tr></table></figure><h4 id="切点表达式组合"><a href="#切点表达式组合" class="headerlink" title="切点表达式组合"></a>切点表达式组合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配以 Service 或 ServiceImpl 结尾的 bean</span></span><br><span class="line">bean(*Service || *ServiceImpl)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配名字以 Service 结尾, 并且在包 com.xys.service 中的 bean</span></span><br><span class="line">bean(*Service) &amp;&amp; within(com.xys.service.*)</span><br></pre></td></tr></table></figure><h2 id="声明-advice"><a href="#声明-advice" class="headerlink" title="声明 advice"></a>声明 advice</h2><p>advice 是和一个 pointcut 表达式关联在一起的, 并且会在匹配的 join point 的方法执行的前/后/周围 运行. <code>pointcut 表达式可以是简单的一个 pointcut 名字的引用, 或者是完整的 pointcut 表达式</code>. 下面我们以几个简单的 advice 为例子, 来看一下一个 advice 是如何声明的.</p><h3 id="Before-advice"><a href="#Before-advice" class="headerlink" title="Before advice"></a>Before advice</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xiongyongshun</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@created</span> 16/9/9 13:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeforeAspectTest</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个 Pointcut, 使用 切点表达式函数 来描述对哪些 Join point 使用 advise.</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.xys.service.UserService.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dataAccessOperation</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdviseDefine</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 advise</span></span><br><span class="line">    <span class="meta">@Before(&quot;com.xys.aspect.PointcutDefine.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doBeforeAccessCheck</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****Before advise, method: &quot;</span> + joinPoint.getSignature().toShortString() + <span class="string">&quot; *****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里, <strong>@Before</strong> 引用了一个 pointcut, 即 “com.xys.aspect.PointcutDefine.dataAccessOperation()” 是一个 pointcut 的名字. 如果我们在 advice 在内置 pointcut, 则可以:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdviseDefine</span> &#123;</span><br><span class="line">    <span class="comment">// 将 pointcut 和 advice 同时定义</span></span><br><span class="line">    <span class="meta">@Before(&quot;within(com.xys.service..*)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doAccessCheck</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;*****doAccessCheck, Before advise, method: &quot;</span> + joinPoint.getSignature().toShortString() + <span class="string">&quot; *****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="around-advice"><a href="#around-advice" class="headerlink" title="around advice"></a>around advice</h3><p>around advice 比较特别, 它可以在一个方法的之前之前和之后添加不同的操作, 并且甚至可以决定何时, 如何, 是否调用匹配到的方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdviseDefine</span> &#123;</span><br><span class="line">    <span class="comment">// 定义 advise</span></span><br><span class="line">    <span class="meta">@Around(&quot;com.xys.aspect.PointcutDefine.dataAccessOperation()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">doAroundAccessCheck</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line">        stopWatch.start();</span><br><span class="line">        <span class="comment">// 开始</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        stopWatch.stop();</span><br><span class="line">        <span class="comment">// 结束</span></span><br><span class="line">        System.out.println(<span class="string">&quot;invoke method: &quot;</span> + pjp.getSignature().getName() + <span class="string">&quot;, elapsed time: &quot;</span> + stopWatch.getTotalTimeMillis());</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>around advice 和前面的 before advice 差不多, 只是我们把注解 <strong>@Before</strong> 改为了 <strong>@Around</strong> 了.</p><h1 id="Java8-Stream-流式编程，极大解放你的生产力！"><a href="#Java8-Stream-流式编程，极大解放你的生产力！" class="headerlink" title="Java8 Stream 流式编程，极大解放你的生产力！"></a>Java8 Stream 流式编程，极大解放你的生产力！</h1><p>[<img src="http://wx.qlogo.cn/mmhead/Q3auHgzwzM6ic4X45AUnpXYUQkPs87V3XX2hTH9r0OK9hbLAD6j77dg/0" alt="小哈学Java"><strong>Java</strong>专注于Java领域干货分享，不限于BAT面试, 算法，数</p><p><code>Stream</code> 流可以说是 Java8 新特性中用起来最爽的一个功能了，有了它，从此操作集合告别繁琐的 <code>for</code> 循环。但是还有很多小伙伴对 Stream 流不是很了解。今天就通过这篇 @Winterbe 的译文，一起深入了解下如何使用它吧。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>一、Stream 流是如何工作的？</p><p>二、不同类型的 Stream 流</p><p>三、Stream 流的处理顺序</p><p>四、中间操作顺序这么重要？</p><p>五、数据流复用问题</p><p>六、高级操作</p><ul><li>6.1 Collect</li><li>6.2 FlatMap</li><li>6.3 Reduce</li></ul><p>七、并行流</p><p>八、结语</p><hr><p>当我第一次阅读 Java8 中的 Stream API 时，说实话，我非常困惑，因为它的名字听起来与 Java I0 框架中的 <code>InputStream</code> 和 <code>OutputStream</code> 非常类似。但是实际上，它们完全是不同的东西。</p><p>Java8 Stream 使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合进行链状流式的操作。</p><p>本文就将带着你如何使用 Java 8 不同类型的 Stream 操作。同时您还将了解流的处理顺序，以及不同顺序的流操作是如何影响运行时性能的。</p><p>我们还将学习终端操作 API <code>reduce</code>， <code>collect</code> 以及 <code>flatMap</code>的详细介绍，最后我们再来深入的探讨一下 Java8 并行流。</p><blockquote><p>注意：如果您还不熟悉 Java 8 lambda 表达式，函数式接口以及方法引用，您可以先阅读一下小哈的另一篇译文 《<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&mid=2247483703&idx=1&sn=9a1721b7ffd578455e29fcdc323e6817&chksm=fd54d1b1ca2358a7c3699a30748bc4e596c89d6d91cd41b2893bbd9c3d572dcfbe72f1567fae&scene=21#wechat_redirect">干货 | Java8 新特性指导手册</a>》</p></blockquote><p>接下来，就让我们进入正题吧！</p><h2 id="一、Stream-流是如何工作的？"><a href="#一、Stream-流是如何工作的？" class="headerlink" title="一、Stream 流是如何工作的？"></a>一、Stream 流是如何工作的？</h2><p>流表示包含着一系列元素的集合，我们可以对其做不同类型的操作，用来对这些元素执行计算。听上去可能有点拗口，让我们用代码说话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; myList =    Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;c2&quot;</span>, <span class="string">&quot;c1&quot;</span>);</span><br><span class="line">myList    .stream() <span class="comment">// 创建流    .filter(s -&gt; s.startsWith(&quot;c&quot;)) // 执行过滤，过滤出以 c 为前缀的字符串    .map(String::toUpperCase) // 转换成大写    .sorted() // 排序    .forEach(System.out::println); // for 循环打印</span></span><br><span class="line"><span class="comment">// C1// C2</span></span><br></pre></td></tr></table></figure><p>我们可以对流进行中间操作或者终端操作。小伙伴们可能会疑问？<strong>什么是中间操作？什么又是终端操作？</strong></p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p><ul><li><strong>①</strong>：中间操作会再次返回一个流，所以，我们可以链接多个中间操作，注意这里是不用加分号的。上图中的 <code>filter</code> 过滤， <code>map</code> 对象转换， <code>sorted</code> 排序，就属于中间操作。</li><li><strong>②</strong>：终端操作是对流操作的一个结束动作，一般返回 <code>void</code> 或者一个非流的结果。上图中的 <code>forEach</code>循环 就是一个终止操作。</li></ul><p>看完上面的操作，感觉是不是很像一个流水线式操作呢。</p><p>实际上，大部分流操作都支持 lambda 表达式作为参数，正确理解，应该说是接受一个函数式接口的实现作为参数。</p><h2 id="二、不同类型的-Stream-流"><a href="#二、不同类型的-Stream-流" class="headerlink" title="二、不同类型的 Stream 流"></a>二、不同类型的 Stream 流</h2><p>我们可以从各种数据源中创建 Stream 流，其中以 Collection 集合最为常见。如 <code>List</code> 和 <code>Set</code> 均支持 <code>stream()</code> 方法来创建顺序流或者是并行流。</p><p>并行流是通过多线程的方式来执行的，它能够充分发挥多核 CPU 的优势来提升性能。本文在最后再来介绍并行流，我们先讨论顺序流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)    .stream() <span class="comment">// 创建流    .findFirst() // 找到第一个元素    .ifPresent(System.out::println);  // 如果存在，即输出</span></span><br><span class="line"><span class="comment">// a1</span></span><br></pre></td></tr></table></figure><p>在集合上调用 <code>stream()</code>方法会返回一个普通的 Stream 流。但是, 您大可不必刻意地创建一个集合，再通过集合来获取 Stream 流，您还可以通过如下这种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)    .findFirst()    .ifPresent(System.out::println);  <span class="comment">// a1</span></span><br></pre></td></tr></table></figure><p>例如上面这样，我们可以通过 <code>Stream.of()</code> 从一堆对象中创建 Stream 流。</p><p>除了常规对象流之外，Java 8还附带了一些特殊类型的流，用于处理原始数据类型 <code>int</code>， <code>long</code>以及 <code>double</code>。说道这里，你可能已经猜到了它们就是 <code>IntStream</code>， <code>LongStream</code>还有 <code>DoubleStream</code>。</p><p>其中， <code>IntStreams.range()</code>方法还可以被用来取代常规的 <code>for</code> 循环, 如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)    .forEach(System.out::println); <span class="comment">// 相当于 for (int i = 1; i &lt; 4; i++) &#123;&#125;</span></span><br><span class="line"><span class="comment">// 1// 2// 3</span></span><br></pre></td></tr></table></figure><p>上面这些原始类型流的工作方式与常规对象流基本是一样的，但还是略微存在一些区别：</p><ul><li>原始类型流使用其独有的函数式接口，例如 <code>IntFunction</code>代替 <code>Function</code>， <code>IntPredicate</code>代替 <code>Predicate</code>。</li><li>原始类型流支持额外的终端聚合操作， <code>sum()</code>以及 <code>average()</code>，如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)    .map(n -&gt; <span class="number">2</span> * n + <span class="number">1</span>) <span class="comment">// 对数值中的每个对象执行 2*n + 1 操作    .average() // 求平均值    .ifPresent(System.out::println);  // 如果值不为空，则输出// 5.0</span></span><br></pre></td></tr></table></figure><p>但是，偶尔我们也有这种需求，需要将常规对象流转换为原始类型流，这个时候，中间操作 <code>mapToInt()</code>， <code>mapToLong()</code> 以及 <code>mapToDouble</code>就派上用场了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;a1&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;a3&quot;</span>)    .map(s -&gt; s.substring(<span class="number">1</span>)) <span class="comment">// 对每个字符串元素从下标1位置开始截取    .mapToInt(Integer::parseInt) // 转成 int 基础类型类型流    .max() // 取最大值    .ifPresent(System.out::println);  // 不为空则输出</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>如果说，您需要将原始类型流装换成对象流，您可以使用 <code>mapToObj()</code>来达到目的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(<span class="number">1</span>, <span class="number">4</span>)    .mapToObj(i -&gt; <span class="string">&quot;a&quot;</span> + i) <span class="comment">// for 循环 1-&gt;4, 拼接前缀 a    .forEach(System.out::println); // for 循环打印</span></span><br><span class="line"><span class="comment">// a1// a2// a3</span></span><br></pre></td></tr></table></figure><p>下面是一个组合示例，我们将双精度流首先转换成 <code>int</code> 类型流，然后再将其装换成对象流：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>)    .mapToInt(Double::intValue) <span class="comment">// double 类型转 int    .mapToObj(i -&gt; &quot;a&quot; + i) // 对值拼接前缀 a    .forEach(System.out::println); // for 循环打印</span></span><br><span class="line"><span class="comment">// a1// a2// a3</span></span><br></pre></td></tr></table></figure><h2 id="三、Stream-流的处理顺序"><a href="#三、Stream-流的处理顺序" class="headerlink" title="三、Stream 流的处理顺序"></a>三、Stream 流的处理顺序</h2><p>上小节中，我们已经学会了如何创建不同类型的 Stream 流，接下来我们再深入了解下数据流的执行顺序。</p><p>在讨论处理顺序之前，您需要明确一点，那就是中间操作的有个重要特性 —— <strong>延迟性</strong>。观察下面这个没有终端操作的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)    .filter(s -&gt; &#123;        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;);</span><br></pre></td></tr></table></figure><p>执行此代码段时，您可能会认为，将依次打印 “d2”, “a2”, “b1”, “b3”, “c” 元素。然而当你实际去执行的时候，它不会打印任何内容。</p><p><strong>为什么呢？</strong></p><p>原因是：当且仅当存在终端操作时，中间操作操作才会被执行。</p><p>是不是不信？接下来，对上面的代码添加 <code>forEach</code>终端操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)    .filter(s -&gt; &#123;        System.out.println(<span class="string">&quot;filter: &quot;</span> + s);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;)    .forEach(s -&gt; System.out.println(<span class="string">&quot;forEach: &quot;</span> + s));</span><br></pre></td></tr></table></figure><p>再次执行，我们会看到输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter:  d2forEach: d2filter:  a2forEach: a2filter:  b1forEach: b1filter:  b3forEach: b3filter:  cforEach: c</span><br></pre></td></tr></table></figure><p>输出的顺序可能会让你很惊讶！你脑海里肯定会想，应该是先将所有 <code>filter</code> 前缀的字符串打印出来，接着才会打印 <code>forEach</code> 前缀的字符串。</p><p>事实上，输出的结果却是随着链条垂直移动的。比如说，当 Stream 开始处理 d2 元素时，它实际上会在执行完 filter 操作后，再执行 forEach 操作，接着才会处理第二个元素。</p><p>是不是很神奇？为什么要设计成这样呢？</p><p>原因是出于性能的考虑。这样设计可以减少对每个元素的实际操作数，看完下面代码你就明白了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)    .map(s -&gt; &#123;        System.out.println(<span class="string">&quot;map: &quot;</span> + s);        <span class="keyword">return</span> s.toUpperCase(); <span class="comment">// 转大写    &#125;)    .anyMatch(s -&gt; &#123;        System.out.println(&quot;anyMatch: &quot; + s);        return s.startsWith(&quot;A&quot;); // 过滤出以 A 为前缀的元素    &#125;);</span></span><br><span class="line"><span class="comment">// map:      d2// anyMatch: D2// map:      a2// anyMatch: A2</span></span><br></pre></td></tr></table></figure><p>终端操作 <code>anyMatch()</code>表示任何一个元素以 A 为前缀，返回为 <code>true</code>，就停止循环。所以它会从 <code>d2</code> 开始匹配，接着循环到 <code>a2</code> 的时候，返回为 <code>true</code> ，于是停止循环。</p><p>由于数据流的链式调用是垂直执行的， <code>map</code>这里只需要执行两次。相对于水平执行来说， <code>map</code>会执行尽可能少的次数，而不是把所有元素都 <code>map</code> 转换一遍。</p><h2 id="四、中间操作顺序这么重要？"><a href="#四、中间操作顺序这么重要？" class="headerlink" title="四、中间操作顺序这么重要？"></a>四、中间操作顺序这么重要？</h2><p>下面的例子由两个中间操作 <code>map</code>和 <code>filter</code>，以及一个终端操作 <code>forEach</code>组成。让我们再来看看这些操作是如何执行的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)    .map(s -&gt; &#123;        System.out.println(<span class="string">&quot;map: &quot;</span> + s);        <span class="keyword">return</span> s.toUpperCase(); <span class="comment">// 转大写    &#125;)    .filter(s -&gt; &#123;        System.out.println(&quot;filter: &quot; + s);        return s.startsWith(&quot;A&quot;); // 过滤出以 A 为前缀的元素    &#125;)    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s)); // for 循环输出</span></span><br><span class="line"><span class="comment">// map:     d2// filter:  D2// map:     a2// filter:  A2// forEach: A2// map:     b1// filter:  B1// map:     b3// filter:  B3// map:     c// filter:  C</span></span><br></pre></td></tr></table></figure><p>学习了上面一小节，您应该已经知道了， <code>map</code>和 <code>filter</code>会对集合中的每个字符串调用五次，而 <code>forEach</code>却只会调用一次，因为只有 “a2” 满足过滤条件。</p><p>如果我们改变中间操作的顺序，将 <code>filter</code>移动到链头的最开始，就可以大大减少实际的执行次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)    .filter(s -&gt; &#123;        System.out.println(<span class="string">&quot;filter: &quot;</span> + s)        <span class="keyword">return</span> s.startsWith(<span class="string">&quot;a&quot;</span>); <span class="comment">// 过滤出以 a 为前缀的元素    &#125;)    .map(s -&gt; &#123;        System.out.println(&quot;map: &quot; + s);        return s.toUpperCase(); // 转大写    &#125;)    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s)); // for 循环输出</span></span><br><span class="line"><span class="comment">// filter:  d2// filter:  a2// map:     a2// forEach: A2// filter:  b1// filter:  b3// filter:  c</span></span><br></pre></td></tr></table></figure><p>现在， <code>map</code>仅仅只需调用一次，性能得到了提升，这种小技巧对于流中存在大量元素来说，是非常很有用的。</p><p>接下来，让我们对上面的代码再添加一个中间操作 <code>sorted</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d2&quot;</span>, <span class="string">&quot;a2&quot;</span>, <span class="string">&quot;b1&quot;</span>, <span class="string">&quot;b3&quot;</span>, <span class="string">&quot;c&quot;</span>)    .sorted((s1, s2) -&gt; &#123;        System.out.printf(<span class="string">&quot;sort: %s; %s\n&quot;</span>, s1, s2);        <span class="keyword">return</span> s1.compareTo(s2); <span class="comment">// 排序    &#125;)    .filter(s -&gt; &#123;        System.out.println(&quot;filter: &quot; + s);        return s.startsWith(&quot;a&quot;); // 过滤出以 a 为前缀的元素    &#125;)    .map(s -&gt; &#123;        System.out.println(&quot;map: &quot; + s);        return s.toUpperCase(); // 转大写    &#125;)    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s)); // for 循环输出</span></span><br></pre></td></tr></table></figure><p><code>sorted</code> 是一个有状态的操作，因为它需要在处理的过程中，保存状态以对集合中的元素进行排序。</p><p>执行上面代码，输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort:    a2; d2sort:    b1; a2sort:    b1; d2sort:    b1; a2sort:    b3; b1sort:    b3; d2sort:    c; b3sort:    c; d2filter:  a2map:     a2forEach: A2filter:  b1filter:  b3filter:  cfilter:  d2</span><br></pre></td></tr></table></figure><p>咦咦咦？这次怎么又不是垂直执行了。你需要知道的是， <code>sorted</code>是水平执行的。因此，在这种情况下， <code>sorted</code>会对集合中的元素组合调用八次。这里，我们也可以利用上面说道的优化技巧，将 filter 过滤中间操作移动到开头部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)    .filter(s -&gt; &#123;        System.out.println(&quot;filter: &quot; + s);        return s.startsWith(&quot;a&quot;);    &#125;)    .sorted((s1, s2) -&gt; &#123;        System.out.printf(&quot;sort: %s; %s\n&quot;, s1, s2);        return s1.compareTo(s2);    &#125;)    .map(s -&gt; &#123;        System.out.println(&quot;map: &quot; + s);        return s.toUpperCase();    &#125;)    .forEach(s -&gt; System.out.println(&quot;forEach: &quot; + s));</span><br><span class="line">// filter:  d2// filter:  a2// filter:  b1// filter:  b3// filter:  c// map:     a2// forEach: A2</span><br></pre></td></tr></table></figure><p>从上面的输出中，我们看到了 <code>sorted</code>从未被调用过，因为经过 <code>filter</code>过后的元素已经减少到只有一个，这种情况下，是不用执行排序操作的。因此性能被大大提高了。</p><h2 id="五、数据流复用问题"><a href="#五、数据流复用问题" class="headerlink" title="五、数据流复用问题"></a>五、数据流复用问题</h2><p>Java8 Stream 流是不能被复用的，一旦你调用任何终端操作，流就会关闭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream =    Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)        .filter(s -&gt; s.startsWith(&quot;a&quot;));</span><br><span class="line">stream.anyMatch(s -&gt; true);    // okstream.noneMatch(s -&gt; true);   // exception</span><br></pre></td></tr></table></figure><p>当我们对 stream 调用了 <code>anyMatch</code> 终端操作以后，流即关闭了，再调用 <code>noneMatch</code> 就会抛出异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)    at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459)    at com.winterbe.java8.Streams5.test7(Streams5.java:38)    at com.winterbe.java8.Streams5.main(Streams5.java:28)</span><br></pre></td></tr></table></figure><p>为了克服这个限制，我们必须为我们想要执行的每个终端操作创建一个新的流链，例如，我们可以通过 <code>Supplier</code> 来包装一下流，通过 <code>get()</code> 方法来构建一个新的 <code>Stream</code> 流，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier =    () -&gt; Stream.of(&quot;d2&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;b3&quot;, &quot;c&quot;)            .filter(s -&gt; s.startsWith(&quot;a&quot;));</span><br><span class="line">streamSupplier.get().anyMatch(s -&gt; true);   // okstreamSupplier.get().noneMatch(s -&gt; true);  // ok</span><br></pre></td></tr></table></figure><p>通过构造一个新的流，来避开流不能被复用的限制, 这也是取巧的一种方式。</p><h2 id="六、高级操作"><a href="#六、高级操作" class="headerlink" title="六、高级操作"></a>六、高级操作</h2><p><code>Streams</code> 支持的操作很丰富，除了上面介绍的这些比较常用的中间操作，如 <code>filter</code>或 <code>map</code>（参见Stream Javadoc）外。还有一些更复杂的操作，如 <code>collect</code>， <code>flatMap</code>以及 <code>reduce</code>。接下来，就让我们学习一下：</p><p>本小节中的大多数代码示例均会使用以下 <code>List&lt;Person&gt;</code>进行演示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;    String name;    int age;</span><br><span class="line">    Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;</span><br><span class="line">    @Override    public String toString() &#123;        return name;    &#125;&#125;</span><br><span class="line">// 构建一个 Person 集合List&lt;Person&gt; persons =    Arrays.asList(        new Person(&quot;Max&quot;, 18),        new Person(&quot;Peter&quot;, 23),        new Person(&quot;Pamela&quot;, 23),        new Person(&quot;David&quot;, 12));</span><br></pre></td></tr></table></figure><h3 id="6-1-Collect"><a href="#6-1-Collect" class="headerlink" title="6.1 Collect"></a>6.1 Collect</h3><p>collect 是一个非常有用的终端操作，它可以将流中的元素转变成另外一个不同的对象，例如一个 <code>List</code>， <code>Set</code>或 <code>Map</code>。collect 接受入参为 <code>Collector</code>（收集器），它由四个不同的操作组成：供应器（supplier）、累加器（accumulator）、组合器（combiner）和终止器（finisher）。</p><p>这些都是个啥？别慌，看上去非常复杂的样子，但好在大多数情况下，您并不需要自己去实现收集器。因为 Java 8通过 <code>Collectors</code>类内置了各种常用的收集器，你直接拿来用就行了。</p><p>让我们先从一个非常常见的用例开始：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; filtered =    persons        .stream() // 构建流        .filter(p -&gt; p.name.startsWith(&quot;P&quot;)) // 过滤出名字以 P 开头的        .collect(Collectors.toList()); // 生成一个新的 List</span><br><span class="line">System.out.println(filtered);    // [Peter, Pamela]</span><br></pre></td></tr></table></figure><p>你也看到了，从流中构造一个 <code>List</code> 异常简单。如果说你需要构造一个 <code>Set</code> 集合，只需要使用 <code>Collectors.toSet()</code>就可以了。</p><p>接下来这个示例，将会按年龄对所有人进行分组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons    .stream()    .collect(Collectors.groupingBy(p -&gt; p.age)); // 以年龄为 key,进行分组</span><br><span class="line">personsByAge    .forEach((age, p) -&gt; System.out.format(&quot;age %s: %s\n&quot;, age, p));</span><br><span class="line">// age 18: [Max]// age 23: [Peter, Pamela]// age 12: [David]</span><br></pre></td></tr></table></figure><p>除了上面这些操作。您还可以在流上执行聚合操作，例如，计算所有人的平均年龄：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Double averageAge = persons    .stream()    .collect(Collectors.averagingInt(p -&gt; p.age)); // 聚合出平均年龄</span><br><span class="line">System.out.println(averageAge);     // 19.0</span><br></pre></td></tr></table></figure><p>如果您还想得到一个更全面的统计信息，摘要收集器可以返回一个特殊的内置统计对象。通过它，我们可以简单地计算出最小年龄、最大年龄、平均年龄、总和以及总数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics ageSummary =    persons        .stream()        .collect(Collectors.summarizingInt(p -&gt; p.age)); // 生成摘要统计</span><br><span class="line">System.out.println(ageSummary);// IntSummaryStatistics&#123;count=4, sum=76, min=12, average=19.000000, max=23&#125;</span><br></pre></td></tr></table></figure><p>下一个这个示例，可以将所有人名连接成一个字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String phrase = persons    .stream()    .filter(p -&gt; p.age &gt;= 18) // 过滤出年龄大于等于18的    .map(p -&gt; p.name) // 提取名字    .collect(Collectors.joining(&quot; and &quot;, &quot;In Germany &quot;, &quot; are of legal age.&quot;)); // 以 In Germany 开头，and 连接各元素，再以 are of legal age. 结束</span><br><span class="line">System.out.println(phrase);// In Germany Max and Peter and Pamela are of legal age.</span><br></pre></td></tr></table></figure><p>连接收集器的入参接受分隔符，以及可选的前缀以及后缀。</p><p>对于如何将流转换为 <code>Map</code>集合，我们必须指定 <code>Map</code> 的键和值。这里需要注意， <code>Map</code> 的键必须是唯一的，否则会抛出 <code>IllegalStateException</code> 异常。</p><p>你可以选择传递一个合并函数作为额外的参数来避免发生这个异常:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = persons    .stream()    .collect(Collectors.toMap(        p -&gt; p.age,        p -&gt; p.name,        (name1, name2) -&gt; name1 + &quot;;&quot; + name2)); // 对于同样 key 的，将值拼接</span><br><span class="line">System.out.println(map);// &#123;18=Max, 23=Peter;Pamela, 12=David&#125;</span><br></pre></td></tr></table></figure><p>既然我们已经知道了这些强大的内置收集器，接下来就让我们尝试构建自定义收集器吧。</p><p>比如说，我们希望将流中的所有人转换成一个字符串，包含所有大写的名称，并以 <code>|</code>分割。为了达到这种效果，我们需要通过 <code>Collector.of()</code>创建一个新的收集器。同时，我们还需要传入收集器的四个组成部分：供应器、累加器、组合器和终止器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Collector&lt;Person, StringJoiner, String&gt; personNameCollector =    Collector.of(        () -&gt; new StringJoiner(&quot; | &quot;),          // supplier 供应器        (j, p) -&gt; j.add(p.name.toUpperCase()),  // accumulator 累加器        (j1, j2) -&gt; j1.merge(j2),               // combiner 组合器        StringJoiner::toString);                // finisher 终止器</span><br><span class="line">String names = persons    .stream()    .collect(personNameCollector); // 传入自定义的收集器</span><br><span class="line">System.out.println(names);  // MAX | PETER | PAMELA | DAVID</span><br></pre></td></tr></table></figure><p>由于Java 中的字符串是 final 类型的，我们需要借助辅助类 <code>StringJoiner</code>，来帮我们构造字符串。</p><p>最开始供应器使用分隔符构造了一个 <code>StringJointer</code>。</p><p>累加器用于将每个人的人名转大写，然后加到 <code>StringJointer</code>中。</p><p>组合器将两个 <code>StringJointer</code>合并为一个。</p><p>最终，终结器从 <code>StringJointer</code>构造出预期的字符串。</p><h3 id="6-2-FlatMap"><a href="#6-2-FlatMap" class="headerlink" title="6.2 FlatMap"></a>6.2 FlatMap</h3><p>上面我们已经学会了如通过 <code>map</code>操作, 将流中的对象转换为另一种类型。但是， <code>Map</code>只能将每个对象映射到另一个对象。</p><p>如果说，我们想要将一个对象转换为多个其他对象或者根本不做转换操作呢？这个时候， <code>flatMap</code>就派上用场了。</p><p><code>FlatMap</code> 能够将流的每个元素, 转换为其他对象的流。因此，每个对象可以被转换为零个，一个或多个其他对象，并以流的方式返回。之后，这些流的内容会被放入 <code>flatMap</code>返回的流中。</p><p>在学习如何实际操作 <code>flatMap</code>之前，我们先新建两个类，用来测试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Foo &#123;    String name;    List&lt;Bar&gt; bars = new ArrayList&lt;&gt;();</span><br><span class="line">    Foo(String name) &#123;        this.name = name;    &#125;&#125;</span><br><span class="line">class Bar &#123;    String name;</span><br><span class="line">    Bar(String name) &#123;        this.name = name;    &#125;&#125;</span><br></pre></td></tr></table></figure><p>接下来，通过我们上面学习到的流知识，来实例化一些对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Foo&gt; foos = new ArrayList&lt;&gt;();</span><br><span class="line">// 创建 foos 集合IntStream    .range(1, 4)    .forEach(i -&gt; foos.add(new Foo(&quot;Foo&quot; + i)));</span><br><span class="line">// 创建 bars 集合foos.forEach(f -&gt;    IntStream        .range(1, 4)        .forEach(i -&gt; f.bars.add(new Bar(&quot;Bar&quot; + i + &quot; &lt;- &quot; + f.name))));</span><br></pre></td></tr></table></figure><p>我们创建了包含三个 <code>foo</code>的集合，每个 <code>foo</code>中又包含三个 <code>bar</code>。</p><p><code>flatMap</code> 的入参接受一个返回对象流的函数。为了处理每个 <code>foo</code>中的 <code>bar</code>，我们需要传入相应 stream 流：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foos.stream()    .flatMap(f -&gt; f.bars.stream())    .forEach(b -&gt; System.out.println(b.name));</span><br><span class="line">// Bar1 &lt;- Foo1// Bar2 &lt;- Foo1// Bar3 &lt;- Foo1// Bar1 &lt;- Foo2// Bar2 &lt;- Foo2// Bar3 &lt;- Foo2// Bar1 &lt;- Foo3// Bar2 &lt;- Foo3// Bar3 &lt;- Foo3</span><br></pre></td></tr></table></figure><p>如上所示，我们已成功将三个 <code>foo</code>对象的流转换为九个 <code>bar</code>对象的流。</p><p>最后，上面的这段代码可以简化为单一的流式操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(1, 4)    .mapToObj(i -&gt; new Foo(&quot;Foo&quot; + i))    .peek(f -&gt; IntStream.range(1, 4)        .mapToObj(i -&gt; new Bar(&quot;Bar&quot; + i + &quot; &lt;- &quot; f.name))        .forEach(f.bars::add))    .flatMap(f -&gt; f.bars.stream())    .forEach(b -&gt; System.out.println(b.name));</span><br></pre></td></tr></table></figure><p><code>flatMap</code>也可用于Java8引入的 <code>Optional</code>类。<code>Optional</code>的 <code>flatMap</code>操作返回一个 <code>Optional</code>或其他类型的对象。所以它可以用于避免繁琐的 <code>null</code>检查。</p><p>接下来，让我们创建层次更深的对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;    Nested nested;&#125;</span><br><span class="line">class Nested &#123;    Inner inner;&#125;</span><br><span class="line">class Inner &#123;    String foo;&#125;</span><br></pre></td></tr></table></figure><p>为了处理从 Outer 对象中获取最底层的 foo 字符串，你需要添加多个 <code>null</code>检查来避免可能发生的 <code>NullPointerException</code>，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = new Outer();if (outer != null &amp;&amp; outer.nested != null &amp;&amp; outer.nested.inner != null) &#123;    System.out.println(outer.nested.inner.foo);&#125;</span><br></pre></td></tr></table></figure><p>我们还可以使用 <code>Optional</code>的 <code>flatMap</code>操作，来完成上述相同功能的判断，且更加优雅：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional.of(new Outer())    .flatMap(o -&gt; Optional.ofNullable(o.nested))    .flatMap(n -&gt; Optional.ofNullable(n.inner))    .flatMap(i -&gt; Optional.ofNullable(i.foo))    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><p>如果不为空的话，每个 <code>flatMap</code>的调用都会返回预期对象的 <code>Optional</code>包装，否则返回为 <code>null</code>的 <code>Optional</code>包装类。</p><blockquote><p>笔者补充：关于 Optional 可参见我另一篇译文《<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzU4MDUyMDQyNQ==&mid=2247483709&idx=1&sn=95e60956cd8e4946dda33ff0aebb93dc&chksm=fd54d1bbca2358ada7a3db7ddff10be62497b711dbb6409b47c1bc3f0cfc0ef6e95d11c45f76&scene=21#wechat_redirect">如何在 Java8 中风骚走位避开空指针异常</a>》</p></blockquote><h3 id="6-3-Reduce"><a href="#6-3-Reduce" class="headerlink" title="6.3 Reduce"></a>6.3 Reduce</h3><p>规约操作可以将流的所有元素组合成一个结果。Java 8 支持三种不同的 <code>reduce</code>方法。第一种将流中的元素规约成流中的一个元素。</p><p>让我们看看如何使用这种方法，来筛选出年龄最大的那个人：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">persons    .stream()    .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2)    .ifPresent(System.out::println);    // Pamela</span><br></pre></td></tr></table></figure><p><code>reduce</code>方法接受 <code>BinaryOperator</code>积累函数。该函数实际上是两个操作数类型相同的 <code>BiFunction</code>。<code>BiFunction</code>功能和 <code>Function</code>一样，但是它接受两个参数。示例代码中，我们比较两个人的年龄，来返回年龄较大的人。</p><p>第二种 <code>reduce</code>方法接受标识值和 <code>BinaryOperator</code>累加器。此方法可用于构造一个新的 <code>Person</code>，其中包含来自流中所有其他人的聚合名称和年龄：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person result =    persons        .stream()        .reduce(new Person(&quot;&quot;, 0), (p1, p2) -&gt; &#123;            p1.age += p2.age;            p1.name += p2.name;            return p1;        &#125;);</span><br><span class="line">System.out.format(&quot;name=%s; age=%s&quot;, result.name, result.age);// name=MaxPeterPamelaDavid; age=76</span><br></pre></td></tr></table></figure><p>第三种 <code>reduce</code>方法接受三个参数：标识值， <code>BiFunction</code>累加器和类型的组合器函数 <code>BinaryOperator</code>。由于初始值的类型不一定为 <code>Person</code>，我们可以使用这个归约函数来计算所有人的年龄总和：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer ageSum = persons    .stream()    .reduce(0, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2);</span><br><span class="line">System.out.println(ageSum);  // 76</span><br></pre></td></tr></table></figure><p>结果为76，但是内部究竟发生了什么呢？让我们再打印一些调试日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer ageSum = persons    .stream()    .reduce(0,        (sum, p) -&gt; &#123;            System.out.format(&quot;accumulator: sum=%s; person=%s\n&quot;, sum, p);            return sum += p.age;        &#125;,        (sum1, sum2) -&gt; &#123;            System.out.format(&quot;combiner: sum1=%s; sum2=%s\n&quot;, sum1, sum2);            return sum1 + sum2;        &#125;);</span><br><span class="line">// accumulator: sum=0; person=Max// accumulator: sum=18; person=Peter// accumulator: sum=41; person=Pamela// accumulator: sum=64; person=David</span><br></pre></td></tr></table></figure><p>你可以看到，累加器函数完成了所有工作。它首先使用初始值 <code>0</code>和第一个人年龄相加。接下来的三步中 <code>sum</code>会持续增加，直到76。</p><p>等等？好像哪里不太对！组合器从来都没有调用过啊？</p><p>我们以并行流的方式运行上面的代码，看看日志输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer ageSum = persons    .parallelStream()    .reduce(0,        (sum, p) -&gt; &#123;            System.out.format(&quot;accumulator: sum=%s; person=%s\n&quot;, sum, p);            return sum += p.age;        &#125;,        (sum1, sum2) -&gt; &#123;            System.out.format(&quot;combiner: sum1=%s; sum2=%s\n&quot;, sum1, sum2);            return sum1 + sum2;        &#125;);</span><br><span class="line">// accumulator: sum=0; person=Pamela// accumulator: sum=0; person=David// accumulator: sum=0; person=Max// accumulator: sum=0; person=Peter// combiner: sum1=18; sum2=23// combiner: sum1=23; sum2=12// combiner: sum1=41; sum2=35</span><br></pre></td></tr></table></figure><p>并行流的执行方式完全不同。这里组合器被调用了。实际上，由于累加器被并行调用，组合器需要被用于计算部分累加值的总和。</p><p>让我们在下一章深入探讨并行流。</p><h2 id="七、并行流"><a href="#七、并行流" class="headerlink" title="七、并行流"></a>七、并行流</h2><p>流是可以并行执行的，当流中存在大量元素时，可以显著提升性能。并行流底层使用的 <code>ForkJoinPool</code>, 它由 <code>ForkJoinPool.commonPool()</code>方法提供。底层线程池的大小最多为五个 - 具体取决于 CPU 可用核心数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool commonPool = ForkJoinPool.commonPool();System.out.println(commonPool.getParallelism());    // 3</span><br></pre></td></tr></table></figure><p>在我的机器上，公共池初始化默认值为 3。你也可以通过设置以下JVM参数可以减小或增加此值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</span><br></pre></td></tr></table></figure><p>集合支持 <code>parallelStream()</code>方法来创建元素的并行流。或者你可以在已存在的数据流上调用中间方法 <code>parallel()</code>，将串行流转换为并行流，这也是可以的。</p><p>为了详细了解并行流的执行行为，我们在下面的示例代码中，打印当前线程的信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;)    .parallelStream()    .filter(s -&gt; &#123;        System.out.format(&quot;filter: %s [%s]\n&quot;,            s, Thread.currentThread().getName());        return true;    &#125;)    .map(s -&gt; &#123;        System.out.format(&quot;map: %s [%s]\n&quot;,            s, Thread.currentThread().getName());        return s.toUpperCase();    &#125;)    .forEach(s -&gt; System.out.format(&quot;forEach: %s [%s]\n&quot;,        s, Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure><p>通过日志输出，我们可以对哪个线程被用于执行流式操作，有个更深入的理解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter:  b1 [main]filter:  a2 [ForkJoinPool.commonPool-worker-1]map:     a2 [ForkJoinPool.commonPool-worker-1]filter:  c2 [ForkJoinPool.commonPool-worker-3]map:     c2 [ForkJoinPool.commonPool-worker-3]filter:  c1 [ForkJoinPool.commonPool-worker-2]map:     c1 [ForkJoinPool.commonPool-worker-2]forEach: C2 [ForkJoinPool.commonPool-worker-3]forEach: A2 [ForkJoinPool.commonPool-worker-1]map:     b1 [main]forEach: B1 [main]filter:  a1 [ForkJoinPool.commonPool-worker-3]map:     a1 [ForkJoinPool.commonPool-worker-3]forEach: A1 [ForkJoinPool.commonPool-worker-3]forEach: C1 [ForkJoinPool.commonPool-worker-2]</span><br></pre></td></tr></table></figure><p>如您所见，并行流使用了所有的 <code>ForkJoinPool</code>中的可用线程来执行流式操作。在持续的运行中，输出结果可能有所不同，因为所使用的特定线程是非特定的。</p><p>让我们通过添加中间操作 <code>sort</code>来扩展上面示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.asList(&quot;a1&quot;, &quot;a2&quot;, &quot;b1&quot;, &quot;c2&quot;, &quot;c1&quot;)    .parallelStream()    .filter(s -&gt; &#123;        System.out.format(&quot;filter: %s [%s]\n&quot;,            s, Thread.currentThread().getName());        return true;    &#125;)    .map(s -&gt; &#123;        System.out.format(&quot;map: %s [%s]\n&quot;,            s, Thread.currentThread().getName());        return s.toUpperCase();    &#125;)    .sorted((s1, s2) -&gt; &#123;        System.out.format(&quot;sort: %s &lt;&gt; %s [%s]\n&quot;,            s1, s2, Thread.currentThread().getName());        return s1.compareTo(s2);    &#125;)    .forEach(s -&gt; System.out.format(&quot;forEach: %s [%s]\n&quot;,        s, Thread.currentThread().getName()));</span><br></pre></td></tr></table></figure><p>运行代码，输出结果看上去有些奇怪：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter:  c2 [ForkJoinPool.commonPool-worker-3]filter:  c1 [ForkJoinPool.commonPool-worker-2]map:     c1 [ForkJoinPool.commonPool-worker-2]filter:  a2 [ForkJoinPool.commonPool-worker-1]map:     a2 [ForkJoinPool.commonPool-worker-1]filter:  b1 [main]map:     b1 [main]filter:  a1 [ForkJoinPool.commonPool-worker-2]map:     a1 [ForkJoinPool.commonPool-worker-2]map:     c2 [ForkJoinPool.commonPool-worker-3]sort:    A2 &lt;&gt; A1 [main]sort:    B1 &lt;&gt; A2 [main]sort:    C2 &lt;&gt; B1 [main]sort:    C1 &lt;&gt; C2 [main]sort:    C1 &lt;&gt; B1 [main]sort:    C1 &lt;&gt; C2 [main]forEach: A1 [ForkJoinPool.commonPool-worker-1]forEach: C2 [ForkJoinPool.commonPool-worker-3]forEach: B1 [main]forEach: A2 [ForkJoinPool.commonPool-worker-2]forEach: C1 [ForkJoinPool.commonPool-worker-1]</span><br></pre></td></tr></table></figure><p>貌似 <code>sort</code>只在主线程上串行执行。但是实际上，并行流中的 <code>sort</code>在底层使用了Java8中新的方法 <code>Arrays.parallelSort()</code>。如 javadoc官方文档解释的，这个方法会按照数据长度来决定以串行方式，或者以并行的方式来执行。</p><blockquote><p>如果指定数据的长度小于最小数值，它则使用相应的 <code>Arrays.sort</code>方法来进行排序。</p></blockquote><p>回到上小节 <code>reduce</code>的例子。我们已经发现了组合器函数只在并行流中调用，而不不会在串行流中被调用。</p><p>让我们来实际观察一下涉及到哪个线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Person&gt; persons = Arrays.asList(    new Person(&quot;Max&quot;, 18),    new Person(&quot;Peter&quot;, 23),    new Person(&quot;Pamela&quot;, 23),    new Person(&quot;David&quot;, 12));</span><br><span class="line">persons    .parallelStream()    .reduce(0,        (sum, p) -&gt; &#123;            System.out.format(&quot;accumulator: sum=%s; person=%s [%s]\n&quot;,                sum, p, Thread.currentThread().getName());            return sum += p.age;        &#125;,        (sum1, sum2) -&gt; &#123;            System.out.format(&quot;combiner: sum1=%s; sum2=%s [%s]\n&quot;,                sum1, sum2, Thread.currentThread().getName());            return sum1 + sum2;        &#125;);</span><br></pre></td></tr></table></figure><p>通过控制台日志输出，累加器和组合器均在所有可用的线程上并行执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">accumulator: sum=0; person=Pamela; [main]accumulator: sum=0; person=Max;    [ForkJoinPool.commonPool-worker-3]accumulator: sum=0; person=David;  [ForkJoinPool.commonPool-worker-2]accumulator: sum=0; person=Peter;  [ForkJoinPool.commonPool-worker-1]combiner:    sum1=18; sum2=23;     [ForkJoinPool.commonPool-worker-1]combiner:    sum1=23; sum2=12;     [ForkJoinPool.commonPool-worker-2]combiner:    sum1=41; sum2=35;     [ForkJoinPool.commonPool-worker-2]</span><br></pre></td></tr></table></figure><p>总之，你需要记住的是，并行流对含有大量元素的数据流提升性能极大。但是你也需要记住并行流的一些操作，例如 <code>reduce</code>和 <code>collect</code>操作，需要额外的计算（如组合操作），这在串行执行时是并不需要。</p><p>此外，我们也了解了，所有并行流操作都共享相同的 JVM 相关的公共 <code>ForkJoinPool</code>。所以你可能需要避免写出一些又慢又卡的流式操作，这很有可能会拖慢你应用中，严重依赖并行流的其它部分代码的性能。</p><h2 id="八、结语"><a href="#八、结语" class="headerlink" title="八、结语"></a>八、结语</h2><p>Java8 Stream 流编程指南到这里就结束了。如果您有兴趣了解更多有关 Java 8 Stream 流的相关信息，我建议您使用 Stream Javadoc 阅读官方文档。如果您想了解有关底层机制的更多信息，您也可以阅读 Martin Fowlers 关于 Collection Pipelines 的文章。</p><p>最后，祝您学习愉快！</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined">By_Xb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://wtnl.xyz/2023/06/23/%E6%91%98%E6%96%87%E7%AC%94%E8%AE%B0%E4%B8%80/">https://wtnl.xyz/2023/06/23/摘文笔记一/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wtnl.xyz" target="_blank">By_Xb</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring-Boot/">Spring-Boot</a><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/springmvc/">springmvc</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/320" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/23/%E6%91%98%E6%96%87%E7%AC%94%E8%AE%B0%E4%BA%8C/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/320" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">摘文笔记_常用技术二</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/23/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8(%E4%B8%80)/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/u=3388573831,1341912953&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">开源工具总结使用(一)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/23/%E6%96%87%E7%AB%A0%E5%BC%95%E7%94%A8/" title="优秀开源框架及文章"><img class="cover" src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image4/hgtrgh4wt56gtw654gy5t6r.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="title">优秀开源框架及文章</div></div></a></div><div><a href="/2023/06/23/%E6%91%98%E6%96%87%E7%AC%94%E8%AE%B0%E4%BA%8C/" title="摘文笔记_常用技术二"><img class="cover" src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/320" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="title">摘文笔记_常用技术二</div></div></a></div><div><a href="/2023/06/23/Spring-Boot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/" title="快速上手SpringBoot1.X"><img class="cover" src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2589588367,2632593097&fm=26&gp=0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="title">快速上手SpringBoot1.X</div></div></a></div><div><a href="/2023/06/23/Spring-Boot%E9%AB%98%E7%BA%A7/" title="SpringBoot原理,启动流程和监听机制"><img class="cover" src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=478000504,3799133286&fm=26&gp=0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="title">SpringBoot原理,启动流程和监听机制</div></div></a></div><div><a href="/2023/06/23/Spring-Boot%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="SpringBoot入门 整合mybatis,Redis,Junit"><img class="cover" src="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=612207832,1665573603&fm=26&gp=0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="title">SpringBoot入门 整合mybatis,Redis,Junit</div></div></a></div><div><a href="/2023/06/23/springboot%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/" title="springBoot解决跨域的三种方法"><img class="cover" src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image4/20210918212344.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-23</div><div class="title">springBoot解决跨域的三种方法</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images2/author.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">By_Xb</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">72</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">33</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://byxiaobian.github.io/"><i class="fa fa-paper-plane-o"></i><span>前往主页</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content"><p class="div-border blue" style="color:#000;text-align:center"><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/images5-140FGZS0.gif" style="float:left" width="25" height="25"><b>记录一些后端知识</b><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/images5-140FGZS0.gif" style="float:right" width="25" height="25"></p><p class="div-border yellow" style="color:#000;text-align:center"><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/images5-140FGZ249-51.gif" style="float:left" width="25" height="25"><b>分享一些笔记心得</b><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/images5-140FGZ249-51.gif" style="float:right" width="25" height="25"></p><p class="div-border green" style="color:#000;text-align:center"><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/images5-140FGZ250-51.gif" style="float:left" width="25" height="25"><b>吃喝吃喝吃喝吃喝</b><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/images5-140FGZ250-51.gif" style="float:right" width="25" height="25"></p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Log4j2%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD"><span class="toc-text">Log4j2使用以及异步性能</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Log4j2%E7%AE%80%E4%BB%8B"><span class="toc-text">Log4j2简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%89%9B%E9%80%BC%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-text">最牛逼的性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%BC%BA%E7%9A%84%E5%BC%82%E6%AD%A5%E6%80%A7%E8%83%BD"><span class="toc-text">最强的异步性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6GC%EF%BC%88Garbage-free%EF%BC%89"><span class="toc-text">零GC（Garbage-free）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E9%AB%98%E6%80%A7%E8%83%BD-I-O-%E5%86%99%E5%85%A5%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-text">更高性能 I&#x2F;O 写入的支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%BC%BA%E5%A4%A7%E7%9A%84%E5%8F%82%E6%95%B0%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-text">更强大的参数格式化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E5%8D%A0%E4%BD%8D%E7%AC%A6%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8F%82%E6%95%B0"><span class="toc-text">使用{}占位符格式化参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8String-format%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8F%82%E6%95%B0"><span class="toc-text">使用String.format的形式格式化参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8logger-printf%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%8F%82%E6%95%B0"><span class="toc-text">使用logger.printf格式化参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%9C%E6%83%B0%E6%80%A7%E2%80%9D%E6%89%93%E6%97%A5%E5%BF%97%EF%BC%88lazy-logging%EF%BC%89"><span class="toc-text">“惰性”打日志（lazy logging）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E7%AE%80%E5%8C%96%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-text">更简化的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#logback-xml"><span class="toc-text">logback.xml</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#log4j2-xml"><span class="toc-text">log4j2.xml</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%97%A5%E5%BF%97%E6%8A%BD%E8%B1%A1-%E9%97%A8%E9%9D%A2%E9%80%82%E9%85%8D"><span class="toc-text">与其他日志抽象&#x2F;门面适配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-text">其他的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8log4j2%E7%9A%84maven%E4%BE%9D%E8%B5%96"><span class="toc-text">引用log4j2的maven依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%A4%BA%E4%BE%8B"><span class="toc-text">配置文件示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95"><span class="toc-text">XML配置文件语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BALogger"><span class="toc-text">创建Logger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%BC%82%E6%AD%A5%E9%85%8D%E7%BD%AE%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%81%EF%BC%81%EF%BC%89"><span class="toc-text">全异步配置（重要！！）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot-%E7%9A%84%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">SpringBoot 的全局异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%87%86%E5%A4%87"><span class="toc-text">SpringBoot全局异常准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E5%87%86%E5%A4%87"><span class="toc-text">开发准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99"><span class="toc-text">代码编写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">功能测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3-%E6%8B%A6%E6%88%AA%E5%99%A8%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8A%A0%E8%A7%A3%E5%AF%86%EF%BC%81"><span class="toc-text">在SpringBoot项目中，自定义注解+拦截器优雅的实现敏感数据的加解密！</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFMybatis-Plugin"><span class="toc-text">一、什么是Mybatis Plugin</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E5%8A%A0%E8%A7%A3%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">二、实现基于注解的敏感信息加解密拦截器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">2.1 实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%AE%9A%E4%B9%89%E9%9C%80%E8%A6%81%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%9A%84%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E6%B3%A8%E8%A7%A3"><span class="toc-text">2.2 定义需要加密解密的敏感信息注解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%AE%9A%E4%B9%89%E5%8A%A0%E5%AF%86%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">2.3 定义加密接口及其实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%AE%9E%E7%8E%B0%E5%85%A5%E5%8F%82%E5%8A%A0%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">2.4 实现入参加密拦截器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%AE%9A%E4%B9%89%E8%A7%A3%E5%AF%86%E6%8E%A5%E5%8F%A3%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">2.5 定义解密接口及其实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E5%AE%9A%E4%B9%89%E5%87%BA%E5%8F%82%E8%A7%A3%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="toc-text">2.6 定义出参解密拦截器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%B3%A8%E8%A7%A3%E5%AE%9E%E4%BD%93%E7%B1%BB%E4%B8%AD%E9%9C%80%E8%A6%81%E5%8A%A0%E8%A7%A3%E5%AF%86%E7%9A%84%E5%AD%97%E6%AE%B5"><span class="toc-text">3、注解实体类中需要加解密的字段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker-%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%9APortainer"><span class="toc-text">Docker 图形化工具：Portainer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-Docker%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-text">一.Docker图形化工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-DockerUI"><span class="toc-text">二.DockerUI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-Shipyard"><span class="toc-text">三.Shipyard</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-Portainer"><span class="toc-text">四.Portainer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9F%A5%E7%9C%8Bportainer%E9%95%9C%E5%83%8F"><span class="toc-text">1.查看portainer镜像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%89%E6%8B%A9%E5%96%9C%E6%AC%A2%E7%9A%84portainer%E9%A3%8E%E6%A0%BC%E9%95%9C%E5%83%8F%EF%BC%8C%E4%B8%8B%E8%BD%BD"><span class="toc-text">2.选择喜欢的portainer风格镜像，下载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%90%AF%E5%8A%A8dockerui%E5%AE%B9%E5%99%A8"><span class="toc-text">3.启动dockerui容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-web%E7%AE%A1%E7%90%86"><span class="toc-text">4.web管理</span></a></li></ol></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringMVC%EF%BC%9A%E6%B3%A8%E8%A7%A3-ControllerAdvice%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">SpringMVC：注解@ControllerAdvice的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B3%A8%E8%A7%A3-ControllerAdvice%E6%98%AF%E5%A6%82%E4%BD%95%E8%A2%AB%E5%8F%91%E7%8E%B0%E7%9A%84"><span class="toc-text">1. 注解@ControllerAdvice是如何被发现的 ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ControllerAdvice-%E5%AE%9A%E4%B9%89%E4%BF%A1%E6%81%AF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2. @ControllerAdvice 定义信息的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-requestResponseBodyAdvice%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1. requestResponseBodyAdvice的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-modelAttributeAdviceCache%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2. modelAttributeAdviceCache的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-initBinderAdviceCache%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">3. initBinderAdviceCache的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%A4%84%E7%90%86%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82-%E5%B9%B6%E5%8F%91%E8%AF%B7%E6%B1%82%EF%BC%9F"><span class="toc-text">如何优雅处理重复请求&#x2F;并发请求？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%B7%E6%B1%82%E7%BC%96%E5%8F%B7%E5%8E%BB%E9%87%8D"><span class="toc-text">利用唯一请求编号去重</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E5%8F%82%E6%95%B0%E5%8E%BB%E9%87%8D"><span class="toc-text">业务参数去重</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E6%91%98%E8%A6%81%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E6%A0%87%E8%AF%86"><span class="toc-text">计算请求参数的摘要作为参数标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E7%BB%AD%E4%BC%98%E5%8C%96%EF%BC%8C%E8%80%83%E8%99%91%E5%89%94%E9%99%A4%E9%83%A8%E5%88%86%E6%97%B6%E9%97%B4%E5%9B%A0%E5%AD%90"><span class="toc-text">继续优化，考虑剔除部分时间因子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%8E%BB%E9%87%8D%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%8CJava%E5%AE%9E%E7%8E%B0"><span class="toc-text">请求去重工具类，Java实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-AOP%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E8%BE%A3"><span class="toc-text">Spring AOP看这篇就够辣~</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-text">基本知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-AOP"><span class="toc-text">什么是 AOP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD"><span class="toc-text">术语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Aspect-%E5%88%87%E9%9D%A2"><span class="toc-text">Aspect(切面)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#advice-%E5%A2%9E%E5%BC%BA"><span class="toc-text">advice(增强)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%82%B9-join-point"><span class="toc-text">连接点(join point)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%82%B9-point-cut"><span class="toc-text">切点(point cut)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Ejoin-point-%E5%92%8C-point-cut-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">关于join point 和 point cut 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#introduction"><span class="toc-text">introduction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87%E5%AF%B9%E8%B1%A1-Target"><span class="toc-text">目标对象(Target)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP-proxy"><span class="toc-text">AOP proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%87%E5%85%A5-Weaving"><span class="toc-text">织入(Weaving)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#advice-%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">advice 的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-AOP-Proxy"><span class="toc-text">关于 AOP Proxy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3-aspect-join-point-point-cut-advice"><span class="toc-text">彻底理解 aspect, join point, point cut, advice</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AspectJ-%E6%94%AF%E6%8C%81"><span class="toc-text">@AspectJ 支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E8%83%BD-AspectJ-%E6%94%AF%E6%8C%81"><span class="toc-text">使能 @AspectJ 支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Java-Configuration-%E6%96%B9%E5%BC%8F%E4%BD%BF%E8%83%BD-AspectJ"><span class="toc-text">使用 Java Configuration 方式使能@AspectJ</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-XML-%E6%96%B9%E5%BC%8F%E4%BD%BF%E8%83%BD-AspectJ"><span class="toc-text">使用 XML 方式使能@AspectJ</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-aspect-%E5%88%87%E9%9D%A2"><span class="toc-text">定义 aspect(切面)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-pointcut"><span class="toc-text">声明 pointcut</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%82%B9%E6%A0%87%E5%BF%97%E7%AC%A6-designator"><span class="toc-text">切点标志符(designator)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#execution"><span class="toc-text">execution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#within"><span class="toc-text">within</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#this-%E4%B8%8E-target"><span class="toc-text">this 与 target</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bean"><span class="toc-text">bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#args"><span class="toc-text">args</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#annotation"><span class="toc-text">@annotation</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">常见的切点表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95%E7%AD%BE%E5%90%8D"><span class="toc-text">匹配方法签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E7%B1%BB%E5%9E%8B%E7%AD%BE%E5%90%8D"><span class="toc-text">匹配类型签名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D-Bean-%E5%90%8D%E5%AD%97"><span class="toc-text">匹配 Bean 名字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%87%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%84%E5%90%88"><span class="toc-text">切点表达式组合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E-advice"><span class="toc-text">声明 advice</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Before-advice"><span class="toc-text">Before advice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#around-advice"><span class="toc-text">around advice</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java8-Stream-%E6%B5%81%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%8C%E6%9E%81%E5%A4%A7%E8%A7%A3%E6%94%BE%E4%BD%A0%E7%9A%84%E7%94%9F%E4%BA%A7%E5%8A%9B%EF%BC%81"><span class="toc-text">Java8 Stream 流式编程，极大解放你的生产力！</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Stream-%E6%B5%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F"><span class="toc-text">一、Stream 流是如何工作的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84-Stream-%E6%B5%81"><span class="toc-text">二、不同类型的 Stream 流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Stream-%E6%B5%81%E7%9A%84%E5%A4%84%E7%90%86%E9%A1%BA%E5%BA%8F"><span class="toc-text">三、Stream 流的处理顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F%E8%BF%99%E4%B9%88%E9%87%8D%E8%A6%81%EF%BC%9F"><span class="toc-text">四、中间操作顺序这么重要？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-text">五、数据流复用问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C"><span class="toc-text">六、高级操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Collect"><span class="toc-text">6.1 Collect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-FlatMap"><span class="toc-text">6.2 FlatMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-Reduce"><span class="toc-text">6.3 Reduce</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%B9%B6%E8%A1%8C%E6%B5%81"><span class="toc-text">七、并行流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E7%BB%93%E8%AF%AD"><span class="toc-text">八、结语</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/23/%E6%96%87%E7%AB%A0%E5%BC%95%E7%94%A8/" title="优秀开源框架及文章"><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image4/hgtrgh4wt56gtw654gy5t6r.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="优秀开源框架及文章"></a><div class="content"><a class="title" href="/2023/06/23/%E6%96%87%E7%AB%A0%E5%BC%95%E7%94%A8/" title="优秀开源框架及文章">优秀开源框架及文章</a><time datetime="2023-06-23T06:47:58.943Z" title="发表于 2023-06-23 14:47:58">2023-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/23/%E6%91%98%E9%97%AE%E7%AC%94%E8%AE%B0%E4%B8%89/" title="摘文笔记_常用技术三"><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/320" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="摘文笔记_常用技术三"></a><div class="content"><a class="title" href="/2023/06/23/%E6%91%98%E9%97%AE%E7%AC%94%E8%AE%B0%E4%B8%89/" title="摘文笔记_常用技术三">摘文笔记_常用技术三</a><time datetime="2023-06-23T06:47:58.941Z" title="发表于 2023-06-23 14:47:58">2023-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/23/%E6%91%98%E6%96%87%E7%AC%94%E8%AE%B0%E4%BA%8C/" title="摘文笔记_常用技术二"><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/320" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="摘文笔记_常用技术二"></a><div class="content"><a class="title" href="/2023/06/23/%E6%91%98%E6%96%87%E7%AC%94%E8%AE%B0%E4%BA%8C/" title="摘文笔记_常用技术二">摘文笔记_常用技术二</a><time datetime="2023-06-23T06:47:58.940Z" title="发表于 2023-06-23 14:47:58">2023-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/23/%E6%91%98%E6%96%87%E7%AC%94%E8%AE%B0%E4%B8%80/" title="摘文笔记_常用技术一"><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/320" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="摘文笔记_常用技术一"></a><div class="content"><a class="title" href="/2023/06/23/%E6%91%98%E6%96%87%E7%AC%94%E8%AE%B0%E4%B8%80/" title="摘文笔记_常用技术一">摘文笔记_常用技术一</a><time datetime="2023-06-23T06:47:58.937Z" title="发表于 2023-06-23 14:47:58">2023-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/23/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8(%E4%B8%80)/" title="开源工具总结使用(一)"><img src="https://cdn.jsdelivr.net/gh/byxiaobian/CDN/images/image1/u=3388573831,1341912953&amp;fm=26&amp;fmt=auto&amp;gp=0.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="开源工具总结使用(一)"></a><div class="content"><a class="title" href="/2023/06/23/%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8(%E4%B8%80)/" title="开源工具总结使用(一)">开源工具总结使用(一)</a><time datetime="2023-06-23T06:47:58.935Z" title="发表于 2023-06-23 14:47:58">2023-06-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2016 - 2023 By_Xb</div><div class="footer_custom_text"><p><a target="_blank" href="https://hexo.io/"><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://demo.jerryc.me/"><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://metroui.org.ua/index.html"><img src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/"><img src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/"><img src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-eosin-one.vercel.app/',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'https://twikoo-eosin-one.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.5.1/jquery.min.js"></script><script defer="defer" src="https://at.alicdn.com/t/font_2100218_rqdhd0ud6wd.js?spm=a313x.7781069.1998910419.88&file=font_2100218_rqdhd0ud6wd.js"></script><script defer="defer" src="/js/icon.js"></script><script defer="defer" src="https://cdn.jsdelivr.net/npm/hexo-theme-volantis@latest/source/js/issues.min.js"></script><script defer="defer" src="https://myhkw.cn/player/js/player.js" id="myhk" key="159939764320" m="1"></script><script type="text/javascript" data-pjax src="https://unpkg.com/artitalk"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/shuoshuo/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()

  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax], .pjax-reload script').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><div class="pjax-reload"><script async="async">for(var arr=document.getElementsByClassName("recent-post-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async="async">for(var arr=document.getElementsByClassName("card-widget"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async="async">for(var arr=document.getElementsByClassName("footer_custom_text"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInX"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async="async">for(var arr=document.getElementsByClassName("article-sort-item"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__zoomIn"),arr[i].setAttribute("data-wow-duration",""),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async="async">for(var arr=document.getElementsByClassName("site-card"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInY"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async="async">for(var arr=document.getElementsByClassName("category-lists"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInX"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async="async">for(var arr=document.getElementsByClassName("tag-cloud-list is-center"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__flipInX"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script><script async="async">for(var arr=document.getElementsByClassName("comment-wrap"),i=0;i<arr.length;i++)arr[i].classList.add("wow"),arr[i].classList.add("animate__slideInUp"),arr[i].setAttribute("data-wow-duration","3s"),arr[i].setAttribute("data-wow-delay",""),arr[i].setAttribute("data-wow-offset",""),arr[i].setAttribute("data-wow-iteration","")</script></div><script defer="defer" src="https://cdn.jsdelivr.net/gh/graingert/wow@1.3.0/dist/wow.min.js"></script><script defer="defer" src="/js/wow_init.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>